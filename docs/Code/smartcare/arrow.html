<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of arrow</title>
  <meta name="keywords" content="arrow">
  <meta name="description" content="ARROW  Draw a line with an arrowhead.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">Code</a> &gt; <a href="index.html">smartcare</a> &gt; arrow.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for Code/smartcare&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>arrow
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>ARROW  Draw a line with an arrowhead.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [h,yy,zz] = arrow(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ARROW  Draw a line with an arrowhead.

  ARROW(Start,Stop) draws a line with an arrow from Start to Stop (points
        should be vectors of length 2 or 3, or matrices with 2 or 3
        columns), and returns the graphics handle of the arrow(s).

  ARROW uses the mouse (click-drag) to create an arrow.

  ARROW DEMO &amp; ARROW DEMO2 show 3-D &amp; 2-D demos of the capabilities of ARROW.

  ARROW may be called with a normal argument list or a property-based list.
        ARROW(Start,Stop,Length,BaseAngle,TipAngle,Width,Page,CrossDir) is
        the full normal argument list, where all but the Start and Stop
        points are optional.  If you need to specify a later argument (e.g.,
        Page) but want default values of earlier ones (e.g., TipAngle),
        pass an empty matrix for the earlier ones (e.g., TipAngle=[]).

  ARROW('Property1',PropVal1,'Property2',PropVal2,...) creates arrows with the
        given properties, using default values for any unspecified or given as
        'default' or NaN.  Some properties used for line and patch objects are
        used in a modified fashion, others are passed directly to LINE, PATCH,
        or SET.  For a detailed properties explanation, call ARROW PROPERTIES.

        Start         The starting points.                     B
        Stop          The end points.                         /|\           ^
        Length        Length of the arrowhead in pixels.     /|||\          |
        BaseAngle     Base angle in degrees (ADE).          //|||\\        L|
        TipAngle      Tip angle in degrees (ABC).          ///|||\\\       e|
        Width         Width of the base in pixels.        ////|||\\\\      n|
        Page          Use hardcopy proportions.          /////|D|\\\\\     g|
        CrossDir      Vector || to arrowhead plane.     ////  |||  \\\\    t|
        NormalDir     Vector out of arrowhead plane.   ///    |||    \\\   h|
        Ends          Which end has an arrowhead.     //&lt;-----&gt;||      \\   |
        ObjectHandles Vector of handles to update.   /   base |||        \  V
                                                    E    angle||&lt;--------&gt;C
  ARROW(H,'Prop1',PropVal1,...), where H is a                 |||tipangle
        vector of handles to previously-created arrows        |||
        and/or line objects, will update the previously-      |||
        created arrows according to the current view       --&gt;|A|&lt;-- width
        and any specified properties, and will convert
        two-point line objects to corresponding arrows.  ARROW(H) will update
        the arrows if the current view has changed.  Root, figure, or axes
        handles included in H are replaced by all descendant Arrow objects.

  A property list can follow any specified normal argument list, e.g.,
  ARROW([1 2 3],[0 0 0],36,'BaseAngle',60) creates an arrow from (1,2,3) to
  the origin, with an arrowhead of length 36 pixels and 60-degree base angle.

  Normally, an ARROW is a PATCH object, so any valid PATCH property/value pairs
  can be passed, e.g., ARROW(Start,Stop,'EdgeColor','r','FaceColor','g').
  ARROW will use LINE objects when requested by ARROW(...,'Type','line') or,
  using LINE property/value pairs, ARROW(Start,Stop,'Type','line','Color','b').

  The basic arguments or properties can generally be vectorized to create
  multiple arrows with the same call.  This is done by passing a property
  with one row per arrow, or, if all arrows are to have the same property
  value, just one row may be specified.

  You may want to execute AXIS(AXIS) before calling ARROW so it doesn't change
  the axes on you; ARROW determines the sizes of arrow components BEFORE the
  arrow is plotted, so if ARROW changes axis limits, arrows may be malformed.

  This version of ARROW uses features of MATLAB 6.x and is incompatible with
  earlier MATLAB versions (ARROW for MATLAB 4.2c is available separately);
  some problems with perspective plots still exist.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../Code/pdm/recovery/updatedModel/amEMMCPlotSuperimposedAlignedCurvesForPaper3Recovery.html" class="code" title="function amEMMCPlotSuperimposedAlignedCurvesForPaper3Recovery(meancurvemean, meancurvecount, amIntrNormcube, amInterventions, normmean, normstd,measures, offset, align_wind, nmeasures, run_type, ex_start, plotname, plotsubfolder, nlatentcurves,countthreshold, shiftmode, study, examplemode, lcexamples)">amEMMCPlotSuperimposedAlignedCurvesForPaper3Recovery</a>	amEMMCPlotSuperimposedAlignedCurves3 - wrapper around the</li><li><a href="amEMMCPlotSuperimposedAlignedCurvesForPaper3.html" class="code" title="function amEMMCPlotSuperimposedAlignedCurvesForPaper3(meancurvemean, meancurvecount, amIntrNormcube, amInterventions, normmean, normstd,measures, min_offset, max_offset, align_wind, nmeasures, run_type, ex_start, plotname, plotsubfolder, nlatentcurves,countthreshold, shiftmode, study, examplemode, lcexamples)">amEMMCPlotSuperimposedAlignedCurvesForPaper3</a>	amEMMCPlotSuperimposedAlignedCurves3 - wrapper around the</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function out = arrow_defcheck(in,def,prop)</a></li><li><a href="#_sub2" class="code">function [H,oldaxlims,errstr] = arrow_clicks(H,ud,x,y,z,ax,oldaxlims)</a></li><li><a href="#_sub3" class="code">function [wasInterrupted,errstr] = arrow_click(lockStart,H,prop,ax)</a></li><li><a href="#_sub4" class="code">function arrow_callback(varargin)</a></li><li><a href="#_sub5" class="code">function out = arrow_point(ax,use_z)</a></li><li><a href="#_sub6" class="code">function [wasKeyPress,wasInterrupted,errstr] = arrow_wfbdown(fig)</a></li><li><a href="#_sub7" class="code">function [out,is2D] = arrow_is2DXY(ax)</a></li><li><a href="#_sub8" class="code">function out = arrow_planarkids(ax)</a></li><li><a href="#_sub9" class="code">function arrow_fixlimits(ax,lims)</a></li><li><a href="#_sub10" class="code">function out = arrow_WarpToFill(notstretched,manualcamera,curax)</a></li><li><a href="#_sub11" class="code">function out = arrow_warnlimits(ax,narrows)</a></li><li><a href="#_sub12" class="code">function arrow_copyprops(fm,to)</a></li><li><a href="#_sub13" class="code">function arrow_props</a></li><li><a href="#_sub14" class="code">function out = arrow_demo</a></li><li><a href="#_sub15" class="code">function h = arrow_demo3(in)</a></li><li><a href="#_sub16" class="code">function h = arrow_demo2(in)</a></li><li><a href="#_sub17" class="code">function out = trueornan(x)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [h,yy,zz] = arrow(varargin)</a>
0002 <span class="comment">% ARROW  Draw a line with an arrowhead.</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%  ARROW(Start,Stop) draws a line with an arrow from Start to Stop (points</span>
0005 <span class="comment">%        should be vectors of length 2 or 3, or matrices with 2 or 3</span>
0006 <span class="comment">%        columns), and returns the graphics handle of the arrow(s).</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%  ARROW uses the mouse (click-drag) to create an arrow.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%  ARROW DEMO &amp; ARROW DEMO2 show 3-D &amp; 2-D demos of the capabilities of ARROW.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%  ARROW may be called with a normal argument list or a property-based list.</span>
0013 <span class="comment">%        ARROW(Start,Stop,Length,BaseAngle,TipAngle,Width,Page,CrossDir) is</span>
0014 <span class="comment">%        the full normal argument list, where all but the Start and Stop</span>
0015 <span class="comment">%        points are optional.  If you need to specify a later argument (e.g.,</span>
0016 <span class="comment">%        Page) but want default values of earlier ones (e.g., TipAngle),</span>
0017 <span class="comment">%        pass an empty matrix for the earlier ones (e.g., TipAngle=[]).</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%  ARROW('Property1',PropVal1,'Property2',PropVal2,...) creates arrows with the</span>
0020 <span class="comment">%        given properties, using default values for any unspecified or given as</span>
0021 <span class="comment">%        'default' or NaN.  Some properties used for line and patch objects are</span>
0022 <span class="comment">%        used in a modified fashion, others are passed directly to LINE, PATCH,</span>
0023 <span class="comment">%        or SET.  For a detailed properties explanation, call ARROW PROPERTIES.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%        Start         The starting points.                     B</span>
0026 <span class="comment">%        Stop          The end points.                         /|\           ^</span>
0027 <span class="comment">%        Length        Length of the arrowhead in pixels.     /|||\          |</span>
0028 <span class="comment">%        BaseAngle     Base angle in degrees (ADE).          //|||\\        L|</span>
0029 <span class="comment">%        TipAngle      Tip angle in degrees (ABC).          ///|||\\\       e|</span>
0030 <span class="comment">%        Width         Width of the base in pixels.        ////|||\\\\      n|</span>
0031 <span class="comment">%        Page          Use hardcopy proportions.          /////|D|\\\\\     g|</span>
0032 <span class="comment">%        CrossDir      Vector || to arrowhead plane.     ////  |||  \\\\    t|</span>
0033 <span class="comment">%        NormalDir     Vector out of arrowhead plane.   ///    |||    \\\   h|</span>
0034 <span class="comment">%        Ends          Which end has an arrowhead.     //&lt;-----&gt;||      \\   |</span>
0035 <span class="comment">%        ObjectHandles Vector of handles to update.   /   base |||        \  V</span>
0036 <span class="comment">%                                                    E    angle||&lt;--------&gt;C</span>
0037 <span class="comment">%  ARROW(H,'Prop1',PropVal1,...), where H is a                 |||tipangle</span>
0038 <span class="comment">%        vector of handles to previously-created arrows        |||</span>
0039 <span class="comment">%        and/or line objects, will update the previously-      |||</span>
0040 <span class="comment">%        created arrows according to the current view       --&gt;|A|&lt;-- width</span>
0041 <span class="comment">%        and any specified properties, and will convert</span>
0042 <span class="comment">%        two-point line objects to corresponding arrows.  ARROW(H) will update</span>
0043 <span class="comment">%        the arrows if the current view has changed.  Root, figure, or axes</span>
0044 <span class="comment">%        handles included in H are replaced by all descendant Arrow objects.</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%  A property list can follow any specified normal argument list, e.g.,</span>
0047 <span class="comment">%  ARROW([1 2 3],[0 0 0],36,'BaseAngle',60) creates an arrow from (1,2,3) to</span>
0048 <span class="comment">%  the origin, with an arrowhead of length 36 pixels and 60-degree base angle.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%  Normally, an ARROW is a PATCH object, so any valid PATCH property/value pairs</span>
0051 <span class="comment">%  can be passed, e.g., ARROW(Start,Stop,'EdgeColor','r','FaceColor','g').</span>
0052 <span class="comment">%  ARROW will use LINE objects when requested by ARROW(...,'Type','line') or,</span>
0053 <span class="comment">%  using LINE property/value pairs, ARROW(Start,Stop,'Type','line','Color','b').</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%  The basic arguments or properties can generally be vectorized to create</span>
0056 <span class="comment">%  multiple arrows with the same call.  This is done by passing a property</span>
0057 <span class="comment">%  with one row per arrow, or, if all arrows are to have the same property</span>
0058 <span class="comment">%  value, just one row may be specified.</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%  You may want to execute AXIS(AXIS) before calling ARROW so it doesn't change</span>
0061 <span class="comment">%  the axes on you; ARROW determines the sizes of arrow components BEFORE the</span>
0062 <span class="comment">%  arrow is plotted, so if ARROW changes axis limits, arrows may be malformed.</span>
0063 <span class="comment">%</span>
0064 <span class="comment">%  This version of ARROW uses features of MATLAB 6.x and is incompatible with</span>
0065 <span class="comment">%  earlier MATLAB versions (ARROW for MATLAB 4.2c is available separately);</span>
0066 <span class="comment">%  some problems with perspective plots still exist.</span>
0067 
0068 <span class="comment">% Copyright (c)1995-2016, Dr. Erik A. Johnson &lt;JohnsonE@usc.edu&gt;, 5/25/2016</span>
0069 <span class="comment">% http://www.usc.edu/civil_eng/johnsone/</span>
0070 
0071 <span class="comment">% Revision history:</span>
0072 <span class="comment">%    5/25/16  EAJ  Add documentation of 'Type','line'</span>
0073 <span class="comment">%                  Add documentation of how to set color</span>
0074 <span class="comment">%                  Add 'Color' property (which sets both 'EdgeColor' and 'FaceColor' for patch objects)</span>
0075 <span class="comment">%    5/24/16  EAJ  Remove 'EraseMode' in HG2</span>
0076 <span class="comment">%    7/16/14  EAJ  R2014b HandleGraphics2 compatibility</span>
0077 <span class="comment">%    7/14/14  EAJ  5/20/13 patch extension didn't work right in HG2</span>
0078 <span class="comment">%                    so break the arrow along its length instead</span>
0079 <span class="comment">%    5/20/13  EAJ  Extend patch line one more segment so EPS/PDF printed versions</span>
0080 <span class="comment">%                    have nice rounded tips when the LineWidth is wider</span>
0081 <span class="comment">%    2/06/13  EAJ  Add ShortenLength property to shorten length if arrow is short</span>
0082 <span class="comment">%    1/24/13  EAJ  Remove some old comments.</span>
0083 <span class="comment">%    5/20/09  EAJ  Fix view direction in (3D) demo.</span>
0084 <span class="comment">%    6/26/08  EAJ  Replace eval('trycmd','catchcmd') with try, trycmd; catch,</span>
0085 <span class="comment">%                    catchcmd; end; -- break's MATLAB 5 compatibility.</span>
0086 <span class="comment">%    8/26/03  EAJ  Eliminate OpenGL attempted fix since it didn't fix anyway.</span>
0087 <span class="comment">%   11/15/02  EAJ  Accomodate how MATLAB 6.5 handles NaN and logicals</span>
0088 <span class="comment">%    7/28/02  EAJ  Tried (but failed) work-around for MATLAB 6.x / OpenGL bug</span>
0089 <span class="comment">%                    if zero 'Width' or not double-ended</span>
0090 <span class="comment">%   11/10/99  EAJ  Add logical() to eliminate zero index problem in MATLAB 5.3.</span>
0091 <span class="comment">%   11/10/99  EAJ  Corrected warning if axis limits changed on multiple axes.</span>
0092 <span class="comment">%   11/10/99  EAJ  Update e-mail address.</span>
0093 <span class="comment">%    2/10/99  EAJ  Some documentation updating.</span>
0094 <span class="comment">%    2/24/98  EAJ  Fixed bug if Start~=Stop but both colinear with viewpoint.</span>
0095 <span class="comment">%    8/14/97  EAJ  Added workaround for MATLAB 5.1 scalar logical transpose bug.</span>
0096 <span class="comment">%    7/21/97  EAJ  Fixed a few misc bugs.</span>
0097 <span class="comment">%    7/14/97  EAJ  Make arrow([],'Prop',...) do nothing (no old handles)</span>
0098 <span class="comment">%    6/23/97  EAJ  MATLAB 5 compatible version, release.</span>
0099 <span class="comment">%    5/27/97  EAJ  Added Line Arrows back in.  Corrected a few bugs.</span>
0100 <span class="comment">%    5/26/97  EAJ  Changed missing Start/Stop to mouse-selected arrows.</span>
0101 <span class="comment">%    5/19/97  EAJ  MATLAB 5 compatible version, beta.</span>
0102 <span class="comment">%    4/13/97  EAJ  MATLAB 5 compatible version, alpha.</span>
0103 <span class="comment">%    1/31/97  EAJ  Fixed bug with multiple arrows and unspecified Z coords.</span>
0104 <span class="comment">%   12/05/96  EAJ  Fixed one more bug with log plots and NormalDir specified</span>
0105 <span class="comment">%   10/24/96  EAJ  Fixed bug with log plots and NormalDir specified</span>
0106 <span class="comment">%   11/13/95  EAJ  Corrected handling for 'reverse' axis directions</span>
0107 <span class="comment">%   10/06/95  EAJ  Corrected occasional conflict with SUBPLOT</span>
0108 <span class="comment">%    4/24/95  EAJ  A major rewrite.</span>
0109 <span class="comment">%    Fall 94  EAJ  Original code.</span>
0110 
0111 <span class="comment">% Things to be done:</span>
0112 <span class="comment">%  - in the arrow_clicks section, prompt by printing to the screen so that</span>
0113 <span class="comment">%    the user knows what's going on; also make sure the figure is brought</span>
0114 <span class="comment">%    to the front.</span>
0115 <span class="comment">%  - segment parsing, computing, and plotting into separate subfunctions</span>
0116 <span class="comment">%  - change computing from Xform to Camera paradigms</span>
0117 <span class="comment">%     + this will help especially with 3-D perspective plots</span>
0118 <span class="comment">%     + if the WarpToFill section works right, remove warning code</span>
0119 <span class="comment">%     + when perpsective works properly, remove perspective warning code</span>
0120 <span class="comment">%  - add cell property values and struct property name/values (like get/set)</span>
0121 <span class="comment">%  - get rid of NaN as the &quot;default&quot; data label</span>
0122 <span class="comment">%     + perhaps change userdata to a struct and don't include (or leave</span>
0123 <span class="comment">%       empty) the values specified as default; or use a cell containing</span>
0124 <span class="comment">%       an empty matrix for a default value</span>
0125 <span class="comment">%  - add functionality of GET to retrieve current values of ARROW properties</span>
0126 <span class="comment">%</span>
0127 <span class="comment">% New list of things to be done:</span>
0128 <span class="comment">%  - rewrite as a graphics or class object that updates itself in real time</span>
0129 <span class="comment">%    (but have a 'Static' or 'DoNotUpdate' property to avoid updating)</span>
0130 
0131 <span class="comment">% Permission is granted to distribute ARROW with the toolboxes for the book</span>
0132 <span class="comment">% &quot;Solving Solid Mechanics Problems with MATLAB 5&quot;, by F. Golnaraghi et al.</span>
0133 <span class="comment">% (Prentice Hall, 1999).</span>
0134 
0135 <span class="comment">% Permission is granted to Dr. Josef Bigun to distribute ARROW with his</span>
0136 <span class="comment">% software to reproduce the figures in his image analysis text.</span>
0137 
0138 <span class="comment">% global variable initialization</span>
0139 <span class="keyword">persistent</span> ARROW_PERSP_WARN ARROW_STRETCH_WARN ARROW_AXLIMITS ARROW_AX
0140 <span class="keyword">if</span> isempty(ARROW_PERSP_WARN  ), ARROW_PERSP_WARN  =1; <span class="keyword">end</span>;
0141 <span class="keyword">if</span> isempty(ARROW_STRETCH_WARN), ARROW_STRETCH_WARN=1; <span class="keyword">end</span>;
0142 
0143 <span class="comment">% Handle callbacks</span>
0144 <span class="keyword">if</span> (nargin&gt;0 &amp; isstr(varargin{1}) &amp; strcmp(lower(varargin{1}),<span class="string">'callback'</span>)),
0145     <a href="#_sub4" class="code" title="subfunction arrow_callback(varargin)">arrow_callback</a>(varargin{2:end}); <span class="keyword">return</span>;
0146 <span class="keyword">end</span>;
0147 
0148 <span class="comment">% Are we doing the demo?</span>
0149 c = sprintf(<span class="string">'\n'</span>);
0150 <span class="keyword">if</span> (nargin==1 &amp; isstr(varargin{1})),
0151     arg1 = lower(varargin{1});
0152     <span class="keyword">if</span> strncmp(arg1,<span class="string">'prop'</span>,4), <a href="#_sub13" class="code" title="subfunction arrow_props">arrow_props</a>;
0153     <span class="keyword">elseif</span> strncmp(arg1,<span class="string">'demo'</span>,4)
0154         clf reset
0155         demo_info = <a href="#_sub14" class="code" title="subfunction out = arrow_demo">arrow_demo</a>;
0156         <span class="keyword">if</span> ~strncmp(arg1,<span class="string">'demo2'</span>,5),
0157             hh=<a href="#_sub15" class="code" title="subfunction h = arrow_demo3(in)">arrow_demo3</a>(demo_info);
0158         <span class="keyword">else</span>,
0159             hh=<a href="#_sub16" class="code" title="subfunction h = arrow_demo2(in)">arrow_demo2</a>(demo_info);
0160         <span class="keyword">end</span>;
0161         <span class="keyword">if</span> (nargout&gt;=1), h=hh; <span class="keyword">end</span>;
0162     <span class="keyword">elseif</span> strncmp(arg1,<span class="string">'fixlimits'</span>,3),
0163         <a href="#_sub9" class="code" title="subfunction arrow_fixlimits(ax,lims)">arrow_fixlimits</a>(ARROW_AX,ARROW_AXLIMITS);
0164         ARROW_AXLIMITS=[]; ARROW_AX=[];
0165     <span class="keyword">elseif</span> strncmp(arg1,<span class="string">'help'</span>,4),
0166         disp(help(mfilename));
0167     <span class="keyword">else</span>,
0168         error([upper(mfilename) <span class="string">' got an unknown single-argument string '''</span> deblank(arg1) <span class="string">'''.'</span>]);
0169     <span class="keyword">end</span>;
0170     <span class="keyword">return</span>;
0171 <span class="keyword">end</span>;
0172 
0173 <span class="comment">% Check # of arguments</span>
0174 <span class="keyword">if</span> (nargout&gt;3), error([upper(mfilename) <span class="string">' produces at most 3 output arguments.'</span>]); <span class="keyword">end</span>;
0175 
0176 <span class="comment">% find first property number</span>
0177 firstprop = nargin+1;
0178 <span class="keyword">for</span> k=1:length(varargin), <span class="keyword">if</span> ~isnumeric(varargin{k}) &amp;&amp; ~all(ishandle(varargin{k})), firstprop=k; <span class="keyword">break</span>; <span class="keyword">end</span>; <span class="keyword">end</span>; <span class="comment">%eaj 5/24/16   for k=1:length(varargin), if ~isnumeric(varargin{k}), firstprop=k; break; end; end;</span>
0179 lastnumeric = firstprop-1;
0180 
0181 <span class="comment">% check property list</span>
0182 <span class="keyword">if</span> (firstprop&lt;=nargin),
0183     <span class="keyword">for</span> k=firstprop:2:nargin,
0184         curarg = varargin{k};
0185         <span class="keyword">if</span> ~isstr(curarg) | sum(size(curarg)&gt;1)&gt;1,
0186             error([upper(mfilename) <span class="string">' requires that a property name be a single string.'</span>]);
0187         <span class="keyword">end</span>;
0188     <span class="keyword">end</span>;
0189     <span class="keyword">if</span> (rem(nargin-firstprop,2)~=1),
0190         error([upper(mfilename) <span class="string">' requires that the property '''</span> <span class="keyword">...</span>
0191                varargin{nargin} <span class="string">''' be paired with a property value.'</span>]);
0192     <span class="keyword">end</span>;
0193 <span class="keyword">end</span>;
0194 
0195 <span class="comment">% default output</span>
0196 <span class="keyword">if</span> (nargout&gt;0), h=[]; <span class="keyword">end</span>;
0197 <span class="keyword">if</span> (nargout&gt;1), yy=[]; <span class="keyword">end</span>;
0198 <span class="keyword">if</span> (nargout&gt;2), zz=[]; <span class="keyword">end</span>;
0199 
0200 <span class="comment">% set values to empty matrices</span>
0201 start      = [];
0202 stop       = [];
0203 len        = [];
0204 baseangle  = [];
0205 tipangle   = [];
0206 wid        = [];
0207 page       = [];
0208 crossdir   = [];
0209 ends       = [];
0210 shorten    = [];
0211 ax         = [];
0212 oldh       = [];
0213 ispatch    = [];
0214 defstart      = [NaN NaN NaN];
0215 defstop       = [NaN NaN NaN];
0216 deflen        = 16;
0217 defbaseangle  = 90;
0218 deftipangle   = 16;
0219 defwid        = 0;
0220 defpage       = 0;
0221 defcrossdir   = [NaN NaN NaN];
0222 defends       = 1;
0223 defshorten    = 0;
0224 defoldh       = [];
0225 defispatch    = 1;
0226 
0227 <span class="comment">% The 'Tag' we'll put on our arrows</span>
0228 ArrowTag = <span class="string">'Arrow'</span>;
0229 
0230 <span class="comment">% check for oldstyle arguments</span>
0231 <span class="keyword">if</span> (firstprop==2),
0232     <span class="comment">% assume arg1 is a set of handles</span>
0233     oldh = varargin{1}(:);
0234     <span class="keyword">if</span> isempty(oldh), <span class="keyword">return</span>; <span class="keyword">end</span>;
0235 <span class="keyword">elseif</span> (firstprop&gt;9),
0236     error([upper(mfilename) <span class="string">' takes at most 8 non-property arguments.'</span>]);
0237 <span class="keyword">elseif</span> (firstprop&gt;2),
0238     {start,stop,len,baseangle,tipangle,wid,page,crossdir};
0239     args = [varargin(1:firstprop-1) cell(1,length(ans)-(firstprop-1))];
0240     [start,stop,len,baseangle,tipangle,wid,page,crossdir] = deal(args{:});
0241 <span class="keyword">end</span>;
0242 
0243 <span class="comment">% parse property pairs</span>
0244 extraprops={};
0245 <span class="keyword">for</span> k=firstprop:2:nargin,
0246     prop = varargin{k};
0247     val  = varargin{k+1};
0248     prop = [lower(prop(:)') <span class="string">'      '</span>];
0249     <span class="keyword">if</span>     strncmp(prop,<span class="string">'start'</span>  ,5),   start      = val;
0250     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'stop'</span>   ,4),   stop       = val;
0251     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'len'</span>    ,3),   len        = val(:);
0252     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'base'</span>   ,4),   baseangle  = val(:);
0253     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'tip'</span>    ,3),   tipangle   = val(:);
0254     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'wid'</span>    ,3),   wid        = val(:);
0255     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'page'</span>   ,4),   page       = val;
0256     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'cross'</span>  ,5),   crossdir   = val;
0257     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'norm'</span>   ,4),   <span class="keyword">if</span> (isstr(val)), crossdir=val; <span class="keyword">else</span>, crossdir=val*sqrt(-1); <span class="keyword">end</span>;
0258     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'end'</span>    ,3),   ends       = val;
0259     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'shorten'</span>,5),   shorten    = val;
0260     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'object'</span> ,6),   oldh       = val(:);
0261     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'handle'</span> ,6),   oldh       = val(:);
0262     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'type'</span>   ,4),   ispatch    = val;
0263     <span class="keyword">elseif</span> strncmp(prop,<span class="string">'userd'</span>  ,5),   <span class="comment">%ignore it</span>
0264     <span class="keyword">else</span>,
0265         <span class="comment">% make sure it is a valid patch or line property</span>
0266         <span class="keyword">try</span>
0267             get(0,[<span class="string">'DefaultPatch'</span> varargin{k}]);
0268         <span class="keyword">catch</span>
0269             errstr = lasterr;
0270             <span class="keyword">try</span>
0271                 get(0,[<span class="string">'DefaultLine'</span> varargin{k}]);
0272             <span class="keyword">catch</span>
0273                 errstr(1:max(find(errstr==char(13)|errstr==char(10)))) = <span class="string">''</span>;
0274                 error([upper(mfilename) <span class="string">' got '</span> errstr]);
0275             <span class="keyword">end</span>
0276         <span class="keyword">end</span>;
0277         extraprops={extraprops{:},varargin{k},val};
0278     <span class="keyword">end</span>;
0279 <span class="keyword">end</span>;
0280 
0281 <span class="comment">% Check if we got 'default' values</span>
0282 start     = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(start    ,defstart    ,<span class="string">'Start'</span>        );
0283 stop      = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(stop     ,defstop     ,<span class="string">'Stop'</span>         );
0284 len       = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(len      ,deflen      ,<span class="string">'Length'</span>       );
0285 baseangle = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(baseangle,defbaseangle,<span class="string">'BaseAngle'</span>    );
0286 tipangle  = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(tipangle ,deftipangle ,<span class="string">'TipAngle'</span>     );
0287 wid       = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(wid      ,defwid      ,<span class="string">'Width'</span>        );
0288 crossdir  = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(crossdir ,defcrossdir ,<span class="string">'CrossDir'</span>     );
0289 page      = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(page     ,defpage     ,<span class="string">'Page'</span>         );
0290 ends      = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(ends     ,defends     ,<span class="string">''</span>             );
0291 shorten   = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(shorten  ,defshorten  ,<span class="string">''</span>             );
0292 oldh      = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(oldh     ,[]          ,<span class="string">'ObjectHandles'</span>);
0293 ispatch   = <a href="#_sub1" class="code" title="subfunction out = arrow_defcheck(in,def,prop)">arrow_defcheck</a>(ispatch  ,defispatch  ,<span class="string">''</span>             );
0294 
0295 <span class="comment">% check transpose on arguments</span>
0296 [m,n]=size(start   );   <span class="keyword">if</span> any(m==[2 3])&amp;(n==1|n&gt;3),   start    = start';      <span class="keyword">end</span>;
0297 [m,n]=size(stop    );   <span class="keyword">if</span> any(m==[2 3])&amp;(n==1|n&gt;3),   stop     = stop';       <span class="keyword">end</span>;
0298 [m,n]=size(crossdir);   <span class="keyword">if</span> any(m==[2 3])&amp;(n==1|n&gt;3),   crossdir = crossdir';   <span class="keyword">end</span>;
0299 
0300 <span class="comment">% convert strings to numbers</span>
0301 <span class="keyword">if</span> ~isempty(ends) &amp; isstr(ends),
0302     endsorig = ends;
0303     [m,n] = size(ends);
0304     col = lower([ends(:,1:min(3,n)) ones(m,max(0,3-n))*<span class="string">' '</span>]);
0305     ends = NaN*ones(m,1);
0306     oo = ones(1,m);
0307     ii=find(all(col'==[<span class="string">'non'</span>]'*oo)'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*0; <span class="keyword">end</span>;
0308     ii=find(all(col'==[<span class="string">'sto'</span>]'*oo)'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*1; <span class="keyword">end</span>;
0309     ii=find(all(col'==[<span class="string">'sta'</span>]'*oo)'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*2; <span class="keyword">end</span>;
0310     ii=find(all(col'==[<span class="string">'bot'</span>]'*oo)'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*3; <span class="keyword">end</span>;
0311     <span class="keyword">if</span> any(isnan(ends)),
0312         ii = min(find(isnan(ends)));
0313         error([upper(mfilename) <span class="string">' does not recognize '''</span> deblank(endsorig(ii,:)) <span class="string">''' as a valid ''Ends'' value.'</span>]);
0314     <span class="keyword">end</span>;
0315 <span class="keyword">else</span>,
0316     ends = ends(:);
0317 <span class="keyword">end</span>;
0318 <span class="keyword">if</span> ~isempty(ispatch) &amp; isstr(ispatch),
0319     col = lower(ispatch(:,1));
0320     patchchar=<span class="string">'p'</span>; linechar=<span class="string">'l'</span>; defchar=<span class="string">' '</span>;
0321     mask = col~=patchchar &amp; col~=linechar &amp; col~=defchar;
0322     <span class="keyword">if</span> any(mask),
0323         error([upper(mfilename) <span class="string">' does not recognize '''</span> deblank(ispatch(min(find(mask)),:)) <span class="string">''' as a valid ''Type'' value.'</span>]);
0324     <span class="keyword">end</span>;
0325     ispatch = (col==patchchar)*1 + (col==linechar)*0 + (col==defchar)*defispatch;
0326 <span class="keyword">else</span>,
0327     ispatch = ispatch(:);
0328 <span class="keyword">end</span>;
0329 oldh = oldh(:);
0330 
0331 <span class="comment">% check object handles</span>
0332 <span class="keyword">if</span> ~all(ishandle(oldh)), error([upper(mfilename) <span class="string">' got invalid object handles.'</span>]); <span class="keyword">end</span>;
0333 
0334 <span class="comment">% expand root, figure, and axes handles</span>
0335 <span class="keyword">if</span> ~isempty(oldh),
0336     ohtype = get(oldh,<span class="string">'Type'</span>);
0337     mask = strcmp(ohtype,<span class="string">'root'</span>) | strcmp(ohtype,<span class="string">'figure'</span>) | strcmp(ohtype,<span class="string">'axes'</span>);
0338     <span class="keyword">if</span> any(mask),
0339         oldh = num2cell(oldh);
0340         <span class="keyword">for</span> ii=find(mask)',
0341             oldh(ii) = {findobj(oldh{ii},<span class="string">'Tag'</span>,ArrowTag)};
0342         <span class="keyword">end</span>;
0343         oldh = cat(1,oldh{:});
0344         <span class="keyword">if</span> isempty(oldh), <span class="keyword">return</span>; <span class="keyword">end</span>; <span class="comment">% no arrows to modify, so just leave</span>
0345     <span class="keyword">end</span>;
0346 <span class="keyword">end</span>;
0347 
0348 <span class="comment">% largest argument length</span>
0349 [mstart,junk]=size(start); [mstop,junk]=size(stop); [mcrossdir,junk]=size(crossdir);
0350 argsizes = [length(oldh) mstart mstop                              <span class="keyword">...</span>
0351             length(len) length(baseangle) length(tipangle)         <span class="keyword">...</span>
0352             length(wid) length(page) mcrossdir length(ends) length(shorten)];
0353 args=[<span class="string">'length(ObjectHandle)  '</span>; <span class="keyword">...</span>
0354       <span class="string">'#rows(Start)          '</span>; <span class="keyword">...</span>
0355       <span class="string">'#rows(Stop)           '</span>; <span class="keyword">...</span>
0356       <span class="string">'length(Length)        '</span>; <span class="keyword">...</span>
0357       <span class="string">'length(BaseAngle)     '</span>; <span class="keyword">...</span>
0358       <span class="string">'length(TipAngle)      '</span>; <span class="keyword">...</span>
0359       <span class="string">'length(Width)         '</span>; <span class="keyword">...</span>
0360       <span class="string">'length(Page)          '</span>; <span class="keyword">...</span>
0361       <span class="string">'#rows(CrossDir)       '</span>; <span class="keyword">...</span>
0362       <span class="string">'#rows(Ends)           '</span>; <span class="keyword">...</span>
0363       <span class="string">'length(ShortenLength) '</span>];
0364 <span class="keyword">if</span> (any(imag(crossdir(:))~=0)),
0365     args(9,:) = <span class="string">'#rows(NormalDir)      '</span>;
0366 <span class="keyword">end</span>;
0367 <span class="keyword">if</span> isempty(oldh),
0368     narrows = max(argsizes);
0369 <span class="keyword">else</span>,
0370     narrows = length(oldh);
0371 <span class="keyword">end</span>;
0372 <span class="keyword">if</span> (narrows&lt;=0), narrows=1; <span class="keyword">end</span>;
0373 
0374 <span class="comment">% Check size of arguments</span>
0375 ii = find((argsizes~=0)&amp;(argsizes~=1)&amp;(argsizes~=narrows));
0376 <span class="keyword">if</span> ~isempty(ii),
0377     s = args(ii',:);
0378     <span class="keyword">while</span> ((size(s,2)&gt;1)&amp;((abs(s(:,size(s,2)))==0)|(abs(s(:,size(s,2)))==abs(<span class="string">' '</span>)))),
0379         s = s(:,1:size(s,2)-1);
0380     <span class="keyword">end</span>;
0381     s = [ones(length(ii),1)*[upper(mfilename) <span class="string">' requires that  '</span>] s <span class="keyword">...</span>
0382          ones(length(ii),1)*[<span class="string">'  equal the # of arrows ('</span> num2str(narrows) <span class="string">').'</span> c]];
0383     s = s';
0384     s = s(:)';
0385     s = s(1:length(s)-1);
0386     error(setstr(s));
0387 <span class="keyword">end</span>;
0388 
0389 <span class="comment">% check element length in Start, Stop, and CrossDir</span>
0390 <span class="keyword">if</span> ~isempty(start),
0391     [m,n] = size(start);
0392     <span class="keyword">if</span> (n==2),
0393         start = [start NaN*ones(m,1)];
0394     <span class="keyword">elseif</span> (n~=3),
0395         error([upper(mfilename) <span class="string">' requires 2- or 3-element Start points.'</span>]);
0396     <span class="keyword">end</span>;
0397 <span class="keyword">end</span>;
0398 <span class="keyword">if</span> ~isempty(stop),
0399     [m,n] = size(stop);
0400     <span class="keyword">if</span> (n==2),
0401         stop = [stop NaN*ones(m,1)];
0402     <span class="keyword">elseif</span> (n~=3),
0403         error([upper(mfilename) <span class="string">' requires 2- or 3-element Stop points.'</span>]);
0404     <span class="keyword">end</span>;
0405 <span class="keyword">end</span>;
0406 <span class="keyword">if</span> ~isempty(crossdir),
0407     [m,n] = size(crossdir);
0408     <span class="keyword">if</span> (n&lt;3),
0409         crossdir = [crossdir NaN*ones(m,3-n)];
0410     <span class="keyword">elseif</span> (n~=3),
0411         <span class="keyword">if</span> (all(imag(crossdir(:))==0)),
0412             error([upper(mfilename) <span class="string">' requires 2- or 3-element CrossDir vectors.'</span>]);
0413         <span class="keyword">else</span>,
0414             error([upper(mfilename) <span class="string">' requires 2- or 3-element NormalDir vectors.'</span>]);
0415         <span class="keyword">end</span>;
0416     <span class="keyword">end</span>;
0417 <span class="keyword">end</span>;
0418 
0419 <span class="comment">% fill empty arguments</span>
0420 <span class="keyword">if</span> isempty(start     ),   start      = [Inf Inf Inf];      <span class="keyword">end</span>;
0421 <span class="keyword">if</span> isempty(stop      ),   stop       = [Inf Inf Inf];      <span class="keyword">end</span>;
0422 <span class="keyword">if</span> isempty(len       ),   len        = Inf;                <span class="keyword">end</span>;
0423 <span class="keyword">if</span> isempty(baseangle ),   baseangle  = Inf;                <span class="keyword">end</span>;
0424 <span class="keyword">if</span> isempty(tipangle  ),   tipangle   = Inf;                <span class="keyword">end</span>;
0425 <span class="keyword">if</span> isempty(wid       ),   wid        = Inf;                <span class="keyword">end</span>;
0426 <span class="keyword">if</span> isempty(page      ),   page       = Inf;                <span class="keyword">end</span>;
0427 <span class="keyword">if</span> isempty(crossdir  ),   crossdir   = [Inf Inf Inf];      <span class="keyword">end</span>;
0428 <span class="keyword">if</span> isempty(ends      ),   ends       = Inf;                <span class="keyword">end</span>;
0429 <span class="keyword">if</span> isempty(shorten   ),   shorten    = Inf;                <span class="keyword">end</span>;
0430 <span class="keyword">if</span> isempty(ispatch   ),   ispatch    = Inf;                <span class="keyword">end</span>;
0431 
0432 <span class="comment">% expand single-column arguments</span>
0433 o = ones(narrows,1);
0434 <span class="keyword">if</span> (size(start     ,1)==1),   start      = o * start     ;   <span class="keyword">end</span>;
0435 <span class="keyword">if</span> (size(stop      ,1)==1),   stop       = o * stop      ;   <span class="keyword">end</span>;
0436 <span class="keyword">if</span> (length(len       )==1),   len        = o * len       ;   <span class="keyword">end</span>;
0437 <span class="keyword">if</span> (length(baseangle )==1),   baseangle  = o * baseangle ;   <span class="keyword">end</span>;
0438 <span class="keyword">if</span> (length(tipangle  )==1),   tipangle   = o * tipangle  ;   <span class="keyword">end</span>;
0439 <span class="keyword">if</span> (length(wid       )==1),   wid        = o * wid       ;   <span class="keyword">end</span>;
0440 <span class="keyword">if</span> (length(page      )==1),   page       = o * page      ;   <span class="keyword">end</span>;
0441 <span class="keyword">if</span> (size(crossdir  ,1)==1),   crossdir   = o * crossdir  ;   <span class="keyword">end</span>;
0442 <span class="keyword">if</span> (length(ends      )==1),   ends       = o * ends      ;   <span class="keyword">end</span>;
0443 <span class="keyword">if</span> (length(shorten   )==1),   shorten    = o * shorten   ;   <span class="keyword">end</span>;
0444 <span class="keyword">if</span> (length(ispatch   )==1),   ispatch    = o * ispatch   ;   <span class="keyword">end</span>;
0445 ax = repmat(gca,narrows,1);   <span class="comment">%eaj 7/16/14  ax=gca; if ~isnumeric(ax), ax=double(ax); end; ax=o*ax;</span>
0446 
0447 <span class="comment">% if we've got handles, get the defaults from the handles</span>
0448 <span class="keyword">if</span> ~isempty(oldh),
0449     <span class="keyword">for</span> k=1:narrows,
0450         oh = oldh(k);
0451         ud = get(oh,<span class="string">'UserData'</span>);
0452         ax(k) = get(oh,<span class="string">'Parent'</span>);   <span class="comment">%eaj 7/16/14  get(oh,'Parent'); if ~isnumeric(ans), double(ans); end; ax(k)=ans;</span>
0453         ohtype = get(oh,<span class="string">'Type'</span>);
0454         <span class="keyword">if</span> strcmp(get(oh,<span class="string">'Tag'</span>),ArrowTag), <span class="comment">% if it's an arrow already</span>
0455             <span class="keyword">if</span> isinf(ispatch(k)), ispatch(k)=strcmp(ohtype,<span class="string">'patch'</span>); <span class="keyword">end</span>;
0456             <span class="comment">% arrow UserData format: [start' stop' len base tip wid page crossdir' ends shorten]</span>
0457             start0 = ud(1:3);
0458             stop0  = ud(4:6);
0459             <span class="keyword">if</span> (isinf(len(k))),           len(k)        = ud( 7);   <span class="keyword">end</span>;
0460             <span class="keyword">if</span> (isinf(baseangle(k))),     baseangle(k)  = ud( 8);   <span class="keyword">end</span>;
0461             <span class="keyword">if</span> (isinf(tipangle(k))),      tipangle(k)   = ud( 9);   <span class="keyword">end</span>;
0462             <span class="keyword">if</span> (isinf(wid(k))),           wid(k)        = ud(10);   <span class="keyword">end</span>;
0463             <span class="keyword">if</span> (isinf(page(k))),          page(k)       = ud(11);   <span class="keyword">end</span>;
0464             <span class="keyword">if</span> (isinf(crossdir(k,1))),    crossdir(k,1) = ud(12);   <span class="keyword">end</span>;
0465             <span class="keyword">if</span> (isinf(crossdir(k,2))),    crossdir(k,2) = ud(13);   <span class="keyword">end</span>;
0466             <span class="keyword">if</span> (isinf(crossdir(k,3))),    crossdir(k,3) = ud(14);   <span class="keyword">end</span>;
0467             <span class="keyword">if</span> (isinf(ends(k))),          ends(k)       = ud(15);   <span class="keyword">end</span>;
0468             <span class="keyword">if</span> (isinf(shorten(k))),       shorten(k)    = ud(16);   <span class="keyword">end</span>;
0469         <span class="keyword">elseif</span> strcmp(ohtype,<span class="string">'line'</span>)|strcmp(ohtype,<span class="string">'patch'</span>), <span class="comment">% it's a non-arrow line or patch</span>
0470             convLineToPatch = 1; <span class="comment">%set to make arrow patches when converting from lines.</span>
0471             <span class="keyword">if</span> isinf(ispatch(k)), ispatch(k)=convLineToPatch|strcmp(ohtype,<span class="string">'patch'</span>); <span class="keyword">end</span>;
0472             x=get(oh,<span class="string">'XData'</span>);  x=x(~isnan(x(:)));  <span class="keyword">if</span> isempty(x), x=NaN; <span class="keyword">end</span>;
0473             y=get(oh,<span class="string">'YData'</span>);  y=y(~isnan(y(:)));  <span class="keyword">if</span> isempty(y), y=NaN; <span class="keyword">end</span>;
0474             z=get(oh,<span class="string">'ZData'</span>);  z=z(~isnan(z(:)));  <span class="keyword">if</span> isempty(z), z=NaN; <span class="keyword">end</span>;
0475             start0 = [x(1)   y(1)   z(1)  ];
0476             stop0  = [x(end) y(end) z(end)];
0477         <span class="keyword">else</span>,
0478             error([upper(mfilename) <span class="string">' cannot convert '</span> ohtype <span class="string">' objects.'</span>]);
0479         <span class="keyword">end</span>;
0480         ii=find(isinf(start(k,:)));  <span class="keyword">if</span> ~isempty(ii),  start(k,ii)=start0(ii);  <span class="keyword">end</span>;
0481         ii=find(isinf(stop( k,:)));  <span class="keyword">if</span> ~isempty(ii),  stop( k,ii)=stop0( ii);  <span class="keyword">end</span>;
0482     <span class="keyword">end</span>;
0483 <span class="keyword">end</span>;
0484 
0485 <span class="comment">% convert Inf's to NaN's</span>
0486 start(     isinf(start    )) = NaN;
0487 stop(      isinf(stop     )) = NaN;
0488 len(       isinf(len      )) = NaN;
0489 baseangle( isinf(baseangle)) = NaN;
0490 tipangle(  isinf(tipangle )) = NaN;
0491 wid(       isinf(wid      )) = NaN;
0492 page(      isinf(page     )) = NaN;
0493 crossdir(  isinf(crossdir )) = NaN;
0494 ends(      isinf(ends     )) = NaN;
0495 shorten(   isinf(shorten  )) = NaN;
0496 ispatch(   isinf(ispatch  )) = NaN;
0497 
0498 <span class="comment">% set up the UserData data (here so not corrupted by log10's and such)</span>
0499 ud = [start stop len baseangle tipangle wid page crossdir ends shorten];
0500 
0501 <span class="comment">% Set Page defaults</span>
0502 page = ~isnan(page) &amp; <a href="#_sub17" class="code" title="subfunction out = trueornan(x)">trueornan</a>(page);
0503 
0504 <span class="comment">% Get axes limits, range, min; correct for aspect ratio and log scale</span>
0505 axm       = zeros(3,narrows);
0506 axr       = zeros(3,narrows);
0507 axrev     = zeros(3,narrows);
0508 ap        = zeros(2,narrows);
0509 xyzlog    = zeros(3,narrows);
0510 limmin    = zeros(2,narrows);
0511 limrange  = zeros(2,narrows);
0512 oldaxlims = zeros(6,narrows);
0513 oneax = all(ax==ax(1));
0514 <span class="keyword">if</span> (oneax),
0515     T    = zeros(4,4);
0516     invT = zeros(4,4);
0517 <span class="keyword">else</span>,
0518     T    = zeros(16,narrows);
0519     invT = zeros(16,narrows);
0520 <span class="keyword">end</span>;
0521 axnotdone = true(size(ax));
0522 <span class="keyword">while</span> (any(axnotdone)),
0523     ii = find(axnotdone,1);
0524     curax = ax(ii);
0525     curpage = page(ii);
0526     <span class="comment">% get axes limits and aspect ratio</span>
0527     axl = [get(curax,<span class="string">'XLim'</span>); get(curax,<span class="string">'YLim'</span>); get(curax,<span class="string">'ZLim'</span>)];
0528     ax==curax; oldaxlims(:,ans)=repmat(reshape(axl',[],1),1,sum(ans));
0529     <span class="comment">% get axes size in pixels (points)</span>
0530     u = get(curax,<span class="string">'Units'</span>);
0531     axposoldunits = get(curax,<span class="string">'Position'</span>);
0532     really_curpage = curpage &amp; strcmp(u,<span class="string">'normalized'</span>);
0533     <span class="keyword">if</span> (really_curpage),
0534         curfig = get(curax,<span class="string">'Parent'</span>);
0535         pu = get(curfig,<span class="string">'PaperUnits'</span>);
0536         set(curfig,<span class="string">'PaperUnits'</span>,<span class="string">'points'</span>);
0537         pp = get(curfig,<span class="string">'PaperPosition'</span>);
0538         set(curfig,<span class="string">'PaperUnits'</span>,pu);
0539         set(curax,<span class="string">'Units'</span>,<span class="string">'pixels'</span>);
0540         curapscreen = get(curax,<span class="string">'Position'</span>);
0541         set(curax,<span class="string">'Units'</span>,<span class="string">'normalized'</span>);
0542         curap = pp.*get(curax,<span class="string">'Position'</span>);
0543     <span class="keyword">else</span>,
0544         set(curax,<span class="string">'Units'</span>,<span class="string">'pixels'</span>);
0545         curapscreen = get(curax,<span class="string">'Position'</span>);
0546         curap = curapscreen;
0547     <span class="keyword">end</span>;
0548     set(curax,<span class="string">'Units'</span>,u);
0549     set(curax,<span class="string">'Position'</span>,axposoldunits);
0550     <span class="comment">% handle non-stretched axes position</span>
0551     str_stretch = { <span class="string">'DataAspectRatioMode'</span>    ; <span class="keyword">...</span>
0552                     <span class="string">'PlotBoxAspectRatioMode'</span> ; <span class="keyword">...</span>
0553                     <span class="string">'CameraViewAngleMode'</span>      };
0554     str_camera  = { <span class="string">'CameraPositionMode'</span>  ; <span class="keyword">...</span>
0555                     <span class="string">'CameraTargetMode'</span>    ; <span class="keyword">...</span>
0556                     <span class="string">'CameraViewAngleMode'</span> ; <span class="keyword">...</span>
0557                     <span class="string">'CameraUpVectorMode'</span>    };
0558     notstretched = strcmp(get(curax,str_stretch),<span class="string">'manual'</span>);
0559     manualcamera = strcmp(get(curax,str_camera),<span class="string">'manual'</span>);
0560     <span class="keyword">if</span> ~<a href="#_sub10" class="code" title="subfunction out = arrow_WarpToFill(notstretched,manualcamera,curax)">arrow_WarpToFill</a>(notstretched,manualcamera,curax),
0561         <span class="comment">% give a warning that this has not been thoroughly tested</span>
0562         <span class="keyword">if</span> 0 &amp; ARROW_STRETCH_WARN,
0563             ARROW_STRETCH_WARN = 0;
0564             strs = {str_stretch{1:2},str_camera{:}};
0565             strs = [char(ones(length(strs),1)*sprintf(<span class="string">'\n    '</span>)) char(strs)]';
0566             warning([upper(mfilename) <span class="string">' may not yet work quite right '</span> <span class="keyword">...</span>
0567                      <span class="string">'if any of the following are ''manual'':'</span> strs(:).']);
0568         <span class="keyword">end</span>;
0569         <span class="comment">% find the true pixel size of the actual axes</span>
0570         texttmp = text(axl(1,[1 2 2 1 1 2 2 1]), <span class="keyword">...</span>
0571                        axl(2,[1 1 2 2 1 1 2 2]), <span class="keyword">...</span>
0572                        axl(3,[1 1 1 1 2 2 2 2]),<span class="string">''</span>);
0573         set(texttmp,<span class="string">'Units'</span>,<span class="string">'points'</span>);
0574         textpos = get(texttmp,<span class="string">'Position'</span>);
0575         delete(texttmp);
0576         textpos = cat(1,textpos{:});
0577         textpos = max(textpos(:,1:2)) - min(textpos(:,1:2));
0578         <span class="comment">% adjust the axes position</span>
0579         <span class="keyword">if</span> (really_curpage),
0580             <span class="comment">% adjust to printed size</span>
0581             textpos = textpos * min(curap(3:4)./textpos);
0582             curap = [curap(1:2)+(curap(3:4)-textpos)/2 textpos];
0583         <span class="keyword">else</span>,
0584             <span class="comment">% adjust for pixel roundoff</span>
0585             textpos = textpos * min(curapscreen(3:4)./textpos);
0586             curap = [curap(1:2)+(curap(3:4)-textpos)/2 textpos];
0587         <span class="keyword">end</span>;
0588     <span class="keyword">end</span>;
0589     <span class="keyword">if</span> ARROW_PERSP_WARN &amp; ~strcmp(get(curax,<span class="string">'Projection'</span>),<span class="string">'orthographic'</span>),
0590         ARROW_PERSP_WARN = 0;
0591         warning([upper(mfilename) <span class="string">' does not yet work right for 3-D perspective projection.'</span>]);
0592     <span class="keyword">end</span>;
0593     <span class="comment">% adjust limits for log scale on axes</span>
0594     curxyzlog = strcmp(get(curax,{<span class="string">'XScale'</span> <span class="string">'YScale'</span> <span class="string">'ZScale'</span>})',<span class="string">'log'</span>);
0595     <span class="keyword">if</span> (any(curxyzlog)),
0596         ii = find([curxyzlog;curxyzlog]);
0597         <span class="keyword">if</span> (any(axl(ii)&lt;=0)),
0598             error([upper(mfilename) <span class="string">' does not support non-positive limits on log-scaled axes.'</span>]);
0599         <span class="keyword">else</span>,
0600             axl(ii) = log10(axl(ii));
0601         <span class="keyword">end</span>;
0602     <span class="keyword">end</span>;
0603     <span class="comment">% correct for 'reverse' direction on axes;</span>
0604     curreverse = strcmp(get(curax,{<span class="string">'XDir'</span> <span class="string">'YDir'</span> <span class="string">'ZDir'</span>})',<span class="string">'reverse'</span>);
0605     ii = find(curreverse);
0606     <span class="keyword">if</span> ~isempty(ii),
0607         axl(ii,[1 2])=-axl(ii,[2 1]);
0608     <span class="keyword">end</span>;
0609     <span class="comment">% compute the range of 2-D values</span>
0610     <span class="keyword">try</span>, curT=get(curax,<span class="string">'Xform'</span>); <span class="keyword">catch</span>, num2cell(get(curax,<span class="string">'View'</span>)); curT=viewmtx(ans{:}); <span class="keyword">end</span>;
0611     lim = curT*[0 1 0 1 0 1 0 1;0 0 1 1 0 0 1 1;0 0 0 0 1 1 1 1;1 1 1 1 1 1 1 1];
0612     lim = lim(1:2,:)./([1;1]*lim(4,:));
0613     curlimmin = min(lim')';
0614     curlimrange = max(lim')' - curlimmin;
0615     curinvT = inv(curT);
0616     <span class="keyword">if</span> (~oneax),
0617         curT = curT.';
0618         curinvT = curinvT.';
0619         curT = curT(:);
0620         curinvT = curinvT(:);
0621     <span class="keyword">end</span>;
0622     <span class="comment">% check which arrows to which cur corresponds</span>
0623     ii = find((ax==curax)&amp;(page==curpage));
0624     oo = ones(1,length(ii));
0625     axr(:,ii)      = diff(axl')' * oo;
0626     axm(:,ii)      = axl(:,1)    * oo;
0627     axrev(:,ii)    = curreverse  * oo;
0628     ap(:,ii)       = curap(3:4)' * oo;
0629     xyzlog(:,ii)   = curxyzlog   * oo;
0630     limmin(:,ii)   = curlimmin   * oo;
0631     limrange(:,ii) = curlimrange * oo;
0632     <span class="keyword">if</span> (oneax),
0633         T    = curT;
0634         invT = curinvT;
0635     <span class="keyword">else</span>,
0636         T(:,ii)    = curT    * oo;
0637         invT(:,ii) = curinvT * oo;
0638     <span class="keyword">end</span>;
0639     axnotdone(ii) = zeros(1,length(ii));
0640 <span class="keyword">end</span>;
0641 
0642 <span class="comment">% correct for log scales</span>
0643 curxyzlog = xyzlog.';
0644 ii = find(curxyzlog(:));
0645 <span class="keyword">if</span> ~isempty(ii),
0646     start(   ii) = real(log10(start(   ii)));
0647     stop(    ii) = real(log10(stop(    ii)));
0648     <span class="keyword">if</span> (all(imag(crossdir)==0)), <span class="comment">% pulled (ii) subscript on crossdir, 12/5/96 eaj</span>
0649         crossdir(ii) = real(log10(crossdir(ii)));
0650     <span class="keyword">end</span>;
0651 <span class="keyword">end</span>;
0652 
0653 <span class="comment">% correct for reverse directions</span>
0654 ii = find(axrev.');
0655 <span class="keyword">if</span> ~isempty(ii),
0656     start(   ii) = -start(   ii);
0657     stop(    ii) = -stop(    ii);
0658     crossdir(ii) = -crossdir(ii);
0659 <span class="keyword">end</span>;
0660 
0661 <span class="comment">% transpose start/stop values</span>
0662 start     = start.';
0663 stop      = stop.';
0664 
0665 <span class="comment">% take care of defaults, page was done above</span>
0666 ii=find(isnan(start(:)       ));  <span class="keyword">if</span> ~isempty(ii),  start(ii)       = axm(ii)+axr(ii)/2;                <span class="keyword">end</span>;
0667 ii=find(isnan(stop(:)        ));  <span class="keyword">if</span> ~isempty(ii),  stop(ii)        = axm(ii)+axr(ii)/2;                <span class="keyword">end</span>;
0668 ii=find(isnan(crossdir(:)    ));  <span class="keyword">if</span> ~isempty(ii),  crossdir(ii)    = zeros(length(ii),1);              <span class="keyword">end</span>;
0669 ii=find(isnan(len            ));  <span class="keyword">if</span> ~isempty(ii),  len(ii)         = ones(length(ii),1)*deflen;        <span class="keyword">end</span>;
0670 ii=find(isnan(baseangle      ));  <span class="keyword">if</span> ~isempty(ii),  baseangle(ii)   = ones(length(ii),1)*defbaseangle;  <span class="keyword">end</span>;
0671 ii=find(isnan(tipangle       ));  <span class="keyword">if</span> ~isempty(ii),  tipangle(ii)    = ones(length(ii),1)*deftipangle;   <span class="keyword">end</span>;
0672 ii=find(isnan(wid            ));  <span class="keyword">if</span> ~isempty(ii),  wid(ii)         = ones(length(ii),1)*defwid;        <span class="keyword">end</span>;
0673 ii=find(isnan(ends           ));  <span class="keyword">if</span> ~isempty(ii),  ends(ii)        = ones(length(ii),1)*defends;       <span class="keyword">end</span>;
0674 ii=find(isnan(shorten        ));  <span class="keyword">if</span> ~isempty(ii),  shorten(ii)     = ones(length(ii),1)*defshorten;    <span class="keyword">end</span>;
0675 
0676 <span class="comment">% transpose rest of values</span>
0677 len       = len.';
0678 baseangle = baseangle.';
0679 tipangle  = tipangle.';
0680 wid       = wid.';
0681 page      = page.';
0682 crossdir  = crossdir.';
0683 ends      = ends.';
0684 shorten   = shorten.';
0685 ax        = ax.';
0686 
0687 <span class="comment">% given x, a 3xN matrix of points in 3-space;</span>
0688 <span class="comment">% want to convert to X, the corresponding 4xN 2-space matrix</span>
0689 <span class="comment">%</span>
0690 <span class="comment">%   tmp1=[(x-axm)./axr; ones(1,size(x,1))];</span>
0691 <span class="comment">%   if (oneax), X=T*tmp1;</span>
0692 <span class="comment">%   else, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;</span>
0693 <span class="comment">%         tmp2=zeros(4,4*N); tmp2(:)=tmp1(:);</span>
0694 <span class="comment">%         X=zeros(4,N); X(:)=sum(tmp2)'; end;</span>
0695 <span class="comment">%   X = X ./ (ones(4,1)*X(4,:));</span>
0696 
0697 <span class="comment">% for all points with start==stop, start=stop-(verysmallvalue)*(up-direction);</span>
0698 ii = find(all(start==stop));
0699 <span class="keyword">if</span> ~isempty(ii),
0700     <span class="comment">% find an arrowdir vertical on screen and perpendicular to viewer</span>
0701     <span class="comment">%    transform to 2-D</span>
0702         tmp1 = [(stop(:,ii)-axm(:,ii))./axr(:,ii);ones(1,length(ii))];
0703         <span class="keyword">if</span> (oneax), twoD=T*tmp1;
0704         <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,ii).*tmp1;
0705               tmp2=zeros(4,4*length(ii)); tmp2(:)=tmp1(:);
0706               twoD=zeros(4,length(ii)); twoD(:)=sum(tmp2)'; <span class="keyword">end</span>;
0707         twoD=twoD./(ones(4,1)*twoD(4,:));
0708     <span class="comment">%    move the start point down just slightly</span>
0709         tmp1 = twoD + [0;-1/1000;0;0]*(limrange(2,ii)./ap(2,ii));
0710     <span class="comment">%    transform back to 3-D</span>
0711         <span class="keyword">if</span> (oneax), threeD=invT*tmp1;
0712         <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT(:,ii).*tmp1;
0713               tmp2=zeros(4,4*length(ii)); tmp2(:)=tmp1(:);
0714               threeD=zeros(4,length(ii)); threeD(:)=sum(tmp2)'; <span class="keyword">end</span>;
0715         start(:,ii) = (threeD(1:3,:)./(ones(3,1)*threeD(4,:))).*axr(:,ii)+axm(:,ii);
0716 <span class="keyword">end</span>;
0717 
0718 <span class="comment">% compute along-arrow points</span>
0719 <span class="comment">%    transform Start points</span>
0720     tmp1=[(start-axm)./axr;ones(1,narrows)];
0721     <span class="keyword">if</span> (oneax), X0=T*tmp1;
0722     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;
0723           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0724           X0=zeros(4,narrows); X0(:)=sum(tmp2)'; <span class="keyword">end</span>;
0725     X0=X0./(ones(4,1)*X0(4,:));
0726 <span class="comment">%    transform Stop points</span>
0727     tmp1=[(stop-axm)./axr;ones(1,narrows)];
0728     <span class="keyword">if</span> (oneax), Xf=T*tmp1;
0729     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;
0730           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0731           Xf=zeros(4,narrows); Xf(:)=sum(tmp2)'; <span class="keyword">end</span>;
0732     Xf=Xf./(ones(4,1)*Xf(4,:));
0733 <span class="comment">%    compute pixel distance between points</span>
0734     D = sqrt(sum(((Xf(1:2,:)-X0(1:2,:)).*(ap./limrange)).^2));
0735     D = D + (D==0);  <span class="comment">%eaj new 2/24/98</span>
0736 <span class="comment">%       shorten the length if requested % added 2/6/2013</span>
0737     numends = (ends==1) + (ends==2) + 2*(ends==3);
0738     mask = shorten &amp; D&lt;len.*numends;
0739     len(mask) = D(mask) ./ numends(mask);
0740 <span class="comment">%    compute and modify along-arrow distances</span>
0741     len1 = len;
0742     len2 = len - (len.*tan(tipangle/180*pi)-wid/2).*tan((90-baseangle)/180*pi);
0743     slen0 = zeros(1,narrows);
0744     slen1 = len1 .* ((ends==2)|(ends==3));
0745     slen2 = len2 .* ((ends==2)|(ends==3));
0746     len0 = zeros(1,narrows);
0747     len1  = len1 .* ((ends==1)|(ends==3));
0748     len2  = len2 .* ((ends==1)|(ends==3));
0749     <span class="comment">%    for no start arrowhead</span>
0750         ii=find((ends==1)&amp;(D&lt;len2));
0751         <span class="keyword">if</span> ~isempty(ii),
0752             slen0(ii) = D(ii)-len2(ii);
0753         <span class="keyword">end</span>;
0754     <span class="comment">%    for no end arrowhead</span>
0755         ii=find((ends==2)&amp;(D&lt;slen2));
0756         <span class="keyword">if</span> ~isempty(ii),
0757             len0(ii) = D(ii)-slen2(ii);
0758         <span class="keyword">end</span>;
0759     len1  = len1  + len0;
0760     len2  = len2  + len0;
0761     slen1 = slen1 + slen0;
0762     slen2 = slen2 + slen0;
0763      <span class="comment">% note:  the division by D below will probably not be accurate if both</span>
0764      <span class="comment">%        of the following are true:</span>
0765      <span class="comment">%           1. the ratio of the line length to the arrowhead</span>
0766      <span class="comment">%              length is large</span>
0767      <span class="comment">%           2. the view is highly perspective.</span>
0768 <span class="comment">%    compute stoppoints</span>
0769     tmp1=X0.*(ones(4,1)*(len0./D))+Xf.*(ones(4,1)*(1-len0./D));
0770     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0771     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0772           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0773           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0774     stoppoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0775 <span class="comment">%    compute tippoints</span>
0776     tmp1=X0.*(ones(4,1)*(len1./D))+Xf.*(ones(4,1)*(1-len1./D));
0777     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0778     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0779           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0780           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0781     tippoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0782 <span class="comment">%    compute basepoints</span>
0783     tmp1=X0.*(ones(4,1)*(len2./D))+Xf.*(ones(4,1)*(1-len2./D));
0784     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0785     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0786           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0787           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0788     basepoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0789 <span class="comment">%    compute startpoints</span>
0790     tmp1=X0.*(ones(4,1)*(1-slen0./D))+Xf.*(ones(4,1)*(slen0./D));
0791     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0792     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0793           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0794           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0795     startpoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0796 <span class="comment">%    compute stippoints</span>
0797     tmp1=X0.*(ones(4,1)*(1-slen1./D))+Xf.*(ones(4,1)*(slen1./D));
0798     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0799     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0800           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0801           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0802     stippoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0803 <span class="comment">%    compute sbasepoints</span>
0804     tmp1=X0.*(ones(4,1)*(1-slen2./D))+Xf.*(ones(4,1)*(slen2./D));
0805     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0806     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
0807           tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
0808           tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0809     sbasepoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
0810 
0811 <span class="comment">% compute cross-arrow directions for arrows with NormalDir specified</span>
0812 <span class="keyword">if</span> (any(imag(crossdir(:))~=0)),
0813     ii = find(any(imag(crossdir)~=0));
0814     crossdir(:,ii) = cross((stop(:,ii)-start(:,ii))./axr(:,ii), <span class="keyword">...</span>
0815                            imag(crossdir(:,ii))).*axr(:,ii);
0816 <span class="keyword">end</span>;
0817 
0818 <span class="comment">% compute cross-arrow directions</span>
0819 basecross  = crossdir + basepoint;
0820 tipcross   = crossdir + tippoint;
0821 sbasecross = crossdir + sbasepoint;
0822 stipcross  = crossdir + stippoint;
0823 ii = find(all(crossdir==0)|any(isnan(crossdir)));
0824 <span class="keyword">if</span> ~isempty(ii),
0825     numii = length(ii);
0826     <span class="comment">%    transform start points</span>
0827         tmp1 = [basepoint(:,ii) tippoint(:,ii) sbasepoint(:,ii) stippoint(:,ii)];
0828         tmp1 = (tmp1-axm(:,[ii ii ii ii])) ./ axr(:,[ii ii ii ii]);
0829         tmp1 = [tmp1; ones(1,4*numii)];
0830         <span class="keyword">if</span> (oneax), X0=T*tmp1;
0831         <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,[ii ii ii ii]).*tmp1;
0832               tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
0833               X0=zeros(4,4*numii); X0(:)=sum(tmp2)'; <span class="keyword">end</span>;
0834         X0=X0./(ones(4,1)*X0(4,:));
0835     <span class="comment">%    transform stop points</span>
0836         tmp1 = [(2*stop(:,ii)-start(:,ii)-axm(:,ii))./axr(:,ii);ones(1,numii)];
0837         tmp1 = [tmp1 tmp1 tmp1 tmp1];
0838         <span class="keyword">if</span> (oneax), Xf=T*tmp1;
0839         <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,[ii ii ii ii]).*tmp1;
0840               tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
0841               Xf=zeros(4,4*numii); Xf(:)=sum(tmp2)'; <span class="keyword">end</span>;
0842         Xf=Xf./(ones(4,1)*Xf(4,:));
0843     <span class="comment">%    compute perpendicular directions</span>
0844         pixfact = ((limrange(1,ii)./limrange(2,ii)).*(ap(2,ii)./ap(1,ii))).^2;
0845         pixfact = [pixfact pixfact pixfact pixfact];
0846         pixfact = [pixfact;1./pixfact];
0847         [dummyval,jj] = max(abs(Xf(1:2,:)-X0(1:2,:)));
0848         jj1 = ((1:4)'*ones(1,length(jj))==ones(4,1)*jj);
0849         jj2 = ((1:4)'*ones(1,length(jj))==ones(4,1)*(3-jj));
0850         jj3 = jj1(1:2,:);
0851         Xf(jj1)=Xf(jj1)+(Xf(jj1)-X0(jj1)==0); <span class="comment">%eaj new 2/24/98</span>
0852         Xp = X0;
0853         Xp(jj2) = X0(jj2) + ones(sum(jj2(:)),1);
0854         Xp(jj1) = X0(jj1) - (Xf(jj2)-X0(jj2))./(Xf(jj1)-X0(jj1)) .* pixfact(jj3);
0855     <span class="comment">%    inverse transform the cross points</span>
0856         <span class="keyword">if</span> (oneax), Xp=invT*Xp;
0857         <span class="keyword">else</span>, tmp1=[Xp;Xp;Xp;Xp]; tmp1=invT(:,[ii ii ii ii]).*tmp1;
0858               tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
0859               Xp=zeros(4,4*numii); Xp(:)=sum(tmp2)'; <span class="keyword">end</span>;
0860         Xp=(Xp(1:3,:)./(ones(3,1)*Xp(4,:))).*axr(:,[ii ii ii ii])+axm(:,[ii ii ii ii]);
0861         basecross(:,ii)  = Xp(:,0*numii+(1:numii));
0862         tipcross(:,ii)   = Xp(:,1*numii+(1:numii));
0863         sbasecross(:,ii) = Xp(:,2*numii+(1:numii));
0864         stipcross(:,ii)  = Xp(:,3*numii+(1:numii));
0865 <span class="keyword">end</span>;
0866 
0867 <span class="comment">% compute all points</span>
0868 <span class="comment">%    compute start points</span>
0869     axm11 = [axm axm axm axm axm axm axm axm axm axm axm];
0870     axr11 = [axr axr axr axr axr axr axr axr axr axr axr];
0871     st = [stoppoint tippoint basepoint sbasepoint stippoint startpoint stippoint sbasepoint basepoint tippoint stoppoint];
0872     tmp1 = (st - axm11) ./ axr11;
0873     tmp1 = [tmp1; ones(1,size(tmp1,2))];
0874     <span class="keyword">if</span> (oneax), X0=T*tmp1;
0875     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[T T T T T T T T T T T].*tmp1;
0876           tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
0877           X0=zeros(4,11*narrows); X0(:)=sum(tmp2)'; <span class="keyword">end</span>;
0878     X0=X0./(ones(4,1)*X0(4,:));
0879 <span class="comment">%    compute stop points</span>
0880     tmp1 = ([start tipcross basecross sbasecross stipcross stop stipcross sbasecross basecross tipcross start] <span class="keyword">...</span>
0881          - axm11) ./ axr11;
0882     tmp1 = [tmp1; ones(1,size(tmp1,2))];
0883     <span class="keyword">if</span> (oneax), Xf=T*tmp1;
0884     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[T T T T T T T T T T T].*tmp1;
0885           tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
0886           Xf=zeros(4,11*narrows); Xf(:)=sum(tmp2)'; <span class="keyword">end</span>;
0887     Xf=Xf./(ones(4,1)*Xf(4,:));
0888 <span class="comment">%    compute lengths</span>
0889     len0  = len.*((ends==1)|(ends==3)).*tan(tipangle/180*pi);
0890     slen0 = len.*((ends==2)|(ends==3)).*tan(tipangle/180*pi);
0891     le = [zeros(1,narrows) len0 wid/2 wid/2 slen0 zeros(1,narrows) -slen0 -wid/2 -wid/2 -len0 zeros(1,narrows)];
0892     aprange = ap./limrange;
0893     aprange = [aprange aprange aprange aprange aprange aprange aprange aprange aprange aprange aprange];
0894     D = sqrt(sum(((Xf(1:2,:)-X0(1:2,:)).*aprange).^2));
0895     Dii=find(D==0); <span class="keyword">if</span> ~isempty(Dii), D=D+(D==0); le(Dii)=zeros(1,length(Dii)); <span class="keyword">end</span>; <span class="comment">%should fix DivideByZero warnings</span>
0896     tmp1 = X0.*(ones(4,1)*(1-le./D)) + Xf.*(ones(4,1)*(le./D));
0897 <span class="comment">%    inverse transform</span>
0898     <span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
0899     <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[invT invT invT invT invT invT invT invT invT invT invT].*tmp1;
0900           tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
0901           tmp3=zeros(4,11*narrows); tmp3(:)=sum(tmp2)'; <span class="keyword">end</span>;
0902     pts = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)) .* axr11 + axm11;
0903 
0904 <span class="comment">% correct for ones where the crossdir was specified</span>
0905 ii = find(~(all(crossdir==0)|any(isnan(crossdir))));
0906 <span class="keyword">if</span> ~isempty(ii),
0907     D1 = [pts(:,1*narrows+ii)-pts(:,9*narrows+ii) <span class="keyword">...</span>
0908           pts(:,2*narrows+ii)-pts(:,8*narrows+ii) <span class="keyword">...</span>
0909           pts(:,3*narrows+ii)-pts(:,7*narrows+ii) <span class="keyword">...</span>
0910           pts(:,4*narrows+ii)-pts(:,6*narrows+ii) <span class="keyword">...</span>
0911           pts(:,6*narrows+ii)-pts(:,4*narrows+ii) <span class="keyword">...</span>
0912           pts(:,7*narrows+ii)-pts(:,3*narrows+ii) <span class="keyword">...</span>
0913           pts(:,8*narrows+ii)-pts(:,2*narrows+ii) <span class="keyword">...</span>
0914           pts(:,9*narrows+ii)-pts(:,1*narrows+ii)]/2;
0915     ii = ii'*ones(1,8) + ones(length(ii),1)*[1:4 6:9]*narrows;
0916     ii = ii(:)';
0917     pts(:,ii) = st(:,ii) + D1;
0918 <span class="keyword">end</span>;
0919 
0920 
0921 <span class="comment">% readjust for reverse directions</span>
0922 iicols=(1:narrows)'; iicols=iicols(:,ones(1,11)); iicols=iicols(:).';
0923 tmp1=axrev(:,iicols);
0924 ii = find(tmp1(:)); <span class="keyword">if</span> ~isempty(ii), pts(ii)=-pts(ii); <span class="keyword">end</span>;
0925 
0926 <span class="comment">% change from starting/ending at the stop point to doing it at the midpoint %eaj 7/14/2014</span>
0927 (pts(:,2*narrows+1:3*narrows)+pts(:,3*narrows+1:4*narrows))/2;              <span class="comment">%eaj 7/14/2014</span>
0928 pts = [ans pts(:,[3*narrows+1:end narrows+1:3*narrows]) ans];               <span class="comment">%eaj 7/14/2014</span>
0929 
0930 <span class="comment">% readjust for log scale on axes</span>
0931 tmp1=xyzlog(:,iicols);
0932 ii = find(tmp1(:)); <span class="keyword">if</span> ~isempty(ii), pts(ii)=10.^pts(ii); <span class="keyword">end</span>;
0933 
0934 <span class="comment">% compute the x,y,z coordinates of the patches;</span>
0935 ii = narrows*(0:size(pts,2)/narrows-1)'*ones(1,narrows) + ones(size(pts,2)/narrows,1)*(1:narrows);
0936 ii = ii(:)';
0937 x = zeros(size(pts,2)/narrows,narrows);
0938 y = zeros(size(pts,2)/narrows,narrows);
0939 z = zeros(size(pts,2)/narrows,narrows);
0940 x(:) = pts(1,ii)';
0941 y(:) = pts(2,ii)';
0942 z(:) = pts(3,ii)';
0943 
0944 <span class="comment">% do the output</span>
0945 <span class="keyword">if</span> (nargout&lt;=1),
0946 <span class="comment">%    % create or modify the patches</span>
0947     newpatch = <a href="#_sub17" class="code" title="subfunction out = trueornan(x)">trueornan</a>(ispatch) &amp; (isempty(oldh)|~strcmp(get(oldh,<span class="string">'Type'</span>),<span class="string">'patch'</span>));
0948     newline = ~<a href="#_sub17" class="code" title="subfunction out = trueornan(x)">trueornan</a>(ispatch) &amp; (isempty(oldh)|~strcmp(get(oldh,<span class="string">'Type'</span>),<span class="string">'line'</span>));
0949     <span class="keyword">if</span> isempty(oldh), H=zeros(narrows,1); <span class="keyword">else</span>, H=oldh; <span class="keyword">end</span>;
0950 <span class="comment">%    % make or modify the arrows</span>
0951     <span class="keyword">for</span> k=1:narrows,
0952         <span class="keyword">if</span> all(isnan(ud(k,[3 6])))&amp;<a href="#_sub7" class="code" title="subfunction [out,is2D] = arrow_is2DXY(ax)">arrow_is2DXY</a>(ax(k)), zz=[]; <span class="keyword">else</span>, zz=z(:,k); <span class="keyword">end</span>;
0953         xx=x(:,k); yy=y(:,k);
0954         <span class="keyword">if</span> (0), <span class="comment">% this fix didn't work, so let's not use it -- 8/26/03</span>
0955             <span class="comment">% try to work around a MATLAB 6.x OpenGL bug -- 7/28/02</span>
0956               mask=any([ones(1,2+size(zz,2));diff([xx yy zz],[],1)],2);
0957               xx=xx(mask); yy=yy(mask); <span class="keyword">if</span> ~isempty(zz), zz=zz(mask); <span class="keyword">end</span>;
0958         <span class="keyword">end</span>;
0959         <span class="comment">% plot the patch or line</span>
0960         <span class="keyword">if</span> newpatch(k) || <a href="#_sub17" class="code" title="subfunction out = trueornan(x)">trueornan</a>(ispatch(k)) <span class="comment">%eaj 7/14/2014, 5/25/2016</span>
0961             <span class="comment">% patch is closed so don't need endpoints %eaj 7/14/2014</span>
0962             <span class="keyword">if</span> ~isempty(xx), xx(end)=[]; <span class="keyword">end</span>; <span class="comment">%eaj 7/14/2014</span>
0963             <span class="keyword">if</span> ~isempty(yy), yy(end)=[]; <span class="keyword">end</span>; <span class="comment">%eaj 7/14/2014</span>
0964             <span class="keyword">if</span> ~isempty(zz), zz(end)=[]; <span class="keyword">end</span>; <span class="comment">%eaj 7/14/2014</span>
0965         <span class="keyword">end</span> <span class="comment">%eaj 7/14/2014</span>
0966         xyz = {<span class="string">'XData'</span>,xx,<span class="string">'YData'</span>,yy,<span class="string">'ZData'</span>,zz,<span class="string">'Tag'</span>,ArrowTag};
0967         <span class="keyword">if</span> newpatch(k)|newline(k),
0968             <span class="keyword">if</span> newpatch(k),
0969                 H(k) = patch(xyz{:});
0970             <span class="keyword">else</span>,
0971                 H(k) = line(xyz{:});
0972             <span class="keyword">end</span>;
0973             <span class="keyword">if</span> ~isempty(oldh), <a href="#_sub12" class="code" title="subfunction arrow_copyprops(fm,to)">arrow_copyprops</a>(oldh(k),H(k)); <span class="keyword">end</span>;
0974         <span class="keyword">else</span>,
0975             <span class="keyword">if</span> strcmp(get(H(k),<span class="string">'Type'</span>),<span class="string">'patch'</span>) <span class="comment">%eaj 5/25/16  if ispatch(k)</span>
0976                 xyz = {xyz{:},<span class="string">'CData'</span>,[]};
0977             <span class="keyword">end</span>;
0978             set(H(k),xyz{:});
0979         <span class="keyword">end</span>;
0980     <span class="keyword">end</span>;
0981     <span class="keyword">if</span> ~isempty(oldh), delete(oldh(oldh~=H)); <span class="keyword">end</span>;
0982 <span class="comment">%    % additional properties</span>
0983     set(H,<span class="string">'Clipping'</span>,<span class="string">'off'</span>);
0984     set(H,{<span class="string">'UserData'</span>},num2cell(ud,2));
0985     <span class="keyword">if</span> length(extraprops)&gt;0
0986         ii = find(strcmpi(extraprops(1:2:end),<span class="string">'color'</span>)); <span class="comment">%eaj 5/25/16</span>
0987         ispatch = strcmp(get(H,<span class="string">'Type'</span>),<span class="string">'patch'</span>);
0988         <span class="comment">%eaj start 5/25/16</span>
0989             <span class="keyword">while</span> ~isempty(ii) &amp;&amp; any(ispatch)
0990                 <span class="keyword">if</span> ii&gt;1, set(H,extraprops{1:2*ii-2}); <span class="keyword">end</span>;
0991                 c = extraprops{2*ii};
0992                 extraprops(1:2*ii) = [];
0993                 ii(1) = [];
0994                 <span class="keyword">if</span> all(ispatch) || ischar(c)&amp;&amp;size(c,1)==1 || isnumeric(c)&amp;&amp;isequal(size(c),[1 3])
0995                     set(H,<span class="string">'EdgeColor'</span>,c,<span class="string">'FaceColor'</span>,c)
0996                 <span class="keyword">elseif</span> iscell(c) &amp;&amp; numel(c)~=numel(H)
0997                     set(H(ispatch),<span class="string">'EdgeColor'</span>,c(ispatch),<span class="string">'FaceColor'</span>,c(ispatch));
0998                     set(H(~ispatch),<span class="string">'Color'</span>,c(~ispatch));
0999                 <span class="keyword">elseif</span> isnumeric(c) &amp;&amp; isequal(size(c),[numel(H) 3])
1000                     set(H(ispatch),<span class="string">'EdgeColor'</span>,num2cell(c(ispatch,:),2),<span class="string">'FaceColor'</span>,num2cell(c(ispatch,:),2));
1001                     set(H(~ispatch),<span class="string">'Color'</span>,num2cell(c(~ispatch,:),2));
1002                 <span class="keyword">else</span>
1003                     warning(<span class="string">'ignoring unknown or invalid ''Color'' specification'</span>);
1004                 <span class="keyword">end</span>
1005             <span class="keyword">end</span>
1006         <span class="keyword">if</span> ~isempty(extraprops)
1007         <span class="comment">%eaj end   5/25/16</span>
1008             set(H,extraprops{:});
1009         <span class="keyword">end</span> <span class="comment">%eaj   5/25/16</span>
1010     <span class="keyword">end</span>
1011     <span class="comment">% handle choosing arrow Start and/or Stop locations if unspecified</span>
1012     [H,oldaxlims,errstr] = <a href="#_sub2" class="code" title="subfunction [H,oldaxlims,errstr] = arrow_clicks(H,ud,x,y,z,ax,oldaxlims)">arrow_clicks</a>(H,ud,x,y,z,ax,oldaxlims);
1013     <span class="keyword">if</span> ~isempty(errstr), error([upper(mfilename) <span class="string">' got '</span> errstr]); <span class="keyword">end</span>;
1014     <span class="comment">% set the output</span>
1015     <span class="keyword">if</span> (nargout&gt;0), h=H; <span class="keyword">end</span>;
1016     <span class="comment">% make sure the axis limits did not change</span>
1017     <span class="keyword">if</span> isempty(oldaxlims),
1018         ARROW_AXLIMITS = [];
1019         ARROW_AX = [];
1020     <span class="keyword">else</span>,
1021         lims = get(ax(:),{<span class="string">'XLim'</span>,<span class="string">'YLim'</span>,<span class="string">'ZLim'</span>})';
1022         lims = reshape(cat(2,lims{:}),6,size(lims,2));
1023         mask = <a href="#_sub7" class="code" title="subfunction [out,is2D] = arrow_is2DXY(ax)">arrow_is2DXY</a>(ax(:));
1024         oldaxlims(5:6,mask) = lims(5:6,mask);
1025         <span class="comment">% store them for possible restoring</span>
1026         mask = any(oldaxlims~=lims,1); ARROW_AX=ax(mask); ARROW_AXLIMITS=oldaxlims(:,mask);
1027         <span class="keyword">if</span> any(mask),
1028             warning(<a href="#_sub11" class="code" title="subfunction out = arrow_warnlimits(ax,narrows)">arrow_warnlimits</a>(ARROW_AX,narrows));
1029         <span class="keyword">end</span>;
1030     <span class="keyword">end</span>;
1031 <span class="keyword">else</span>,
1032     <span class="comment">% don't create the patch, just return the data</span>
1033     h=x;
1034     yy=y;
1035     zz=z;
1036 <span class="keyword">end</span>;
1037 
1038 
1039 
1040 <a name="_sub1" href="#_subfunctions" class="code">function out = arrow_defcheck(in,def,prop)</a>
1041 <span class="comment">% check if we got 'default' values</span>
1042     out = in;
1043     <span class="keyword">if</span> ~isstr(in), <span class="keyword">return</span>; <span class="keyword">end</span>;
1044     <span class="keyword">if</span> size(in,1)==1 &amp; strncmp(lower(in),<span class="string">'def'</span>,3),
1045         out = def;
1046     <span class="keyword">elseif</span> ~isempty(prop),
1047         error([upper(mfilename) <span class="string">' does not recognize '''</span> in(:)' <span class="string">''' as a valid '''</span> prop <span class="string">''' string.'</span>]);
1048     <span class="keyword">end</span>;
1049 
1050 
1051 
1052 <a name="_sub2" href="#_subfunctions" class="code">function [H,oldaxlims,errstr] = arrow_clicks(H,ud,x,y,z,ax,oldaxlims)</a>
1053 <span class="comment">% handle choosing arrow Start and/or Stop locations if necessary</span>
1054     errstr = <span class="string">''</span>;
1055     <span class="keyword">if</span> isempty(H)|isempty(ud)|isempty(x), <span class="keyword">return</span>; <span class="keyword">end</span>;
1056     <span class="comment">% determine which (if any) need Start and/or Stop</span>
1057     needStart = all(isnan(ud(:,1:3)'))';
1058     needStop  = all(isnan(ud(:,4:6)'))';
1059     mask = any(needStart|needStop);
1060     <span class="keyword">if</span> ~any(mask), <span class="keyword">return</span>; <span class="keyword">end</span>;
1061     ud(~mask,:)=[]; ax(:,~mask)=[];
1062     x(:,~mask)=[]; y(:,~mask)=[]; z(:,~mask)=[];
1063     <span class="comment">% make them invisible for the time being</span>
1064     set(H,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
1065     <span class="comment">% save the current axes and limits modes; set to manual for the time being</span>
1066     oldAx  = gca;
1067     limModes=get(ax(:),{<span class="string">'XLimMode'</span>,<span class="string">'YLimMode'</span>,<span class="string">'ZLimMode'</span>});
1068     set(ax(:),{<span class="string">'XLimMode'</span>,<span class="string">'YLimMode'</span>,<span class="string">'ZLimMode'</span>},{<span class="string">'manual'</span>,<span class="string">'manual'</span>,<span class="string">'manual'</span>});
1069     <span class="comment">% loop over each arrow that requires attention</span>
1070     jj = find(mask);
1071     <span class="keyword">for</span> ii=1:length(jj),
1072         h = H(jj(ii));
1073         axes(ax(ii));
1074         <span class="comment">% figure out correct call</span>
1075         <span class="keyword">if</span> needStart(ii), prop=<span class="string">'Start'</span>; <span class="keyword">else</span>, prop=<span class="string">'Stop'</span>; <span class="keyword">end</span>;
1076         [wasInterrupted,errstr] = <a href="#_sub3" class="code" title="subfunction [wasInterrupted,errstr] = arrow_click(lockStart,H,prop,ax)">arrow_click</a>(needStart(ii)&amp;needStop(ii),h,prop,ax(ii));
1077         <span class="comment">% handle errors and control-C</span>
1078         <span class="keyword">if</span> wasInterrupted,
1079             delete(H(jj(ii:end)));
1080             H(jj(ii:end))=[];
1081             oldaxlims(jj(ii:end),:)=[];
1082             <span class="keyword">break</span>;
1083         <span class="keyword">end</span>;
1084     <span class="keyword">end</span>;
1085     <span class="comment">% restore the axes and limit modes</span>
1086     axes(oldAx);
1087     set(ax(:),{<span class="string">'XLimMode'</span>,<span class="string">'YLimMode'</span>,<span class="string">'ZLimMode'</span>},limModes);
1088 
1089 <a name="_sub3" href="#_subfunctions" class="code">function [wasInterrupted,errstr] = arrow_click(lockStart,H,prop,ax)</a>
1090 <span class="comment">% handle the clicks for one arrow</span>
1091     fig = get(ax,<span class="string">'Parent'</span>);
1092     <span class="comment">% save some things</span>
1093     oldFigProps = {<span class="string">'Pointer'</span>,<span class="string">'WindowButtonMotionFcn'</span>,<span class="string">'WindowButtonUpFcn'</span>};
1094     oldFigValue = get(fig,oldFigProps);
1095     oldArrowProps = {<span class="string">'EraseMode'</span>};
1096     <span class="keyword">if</span> ~isnumeric(fig), oldArrowProps={}; <span class="keyword">end</span> <span class="comment">%eaj 5/24/16 % only use in HG2</span>
1097     oldArrowValue = get(H,oldArrowProps);
1098     <span class="keyword">if</span> isnumeric(fig), <span class="comment">%eaj 5/24/16</span>
1099         set(H,<span class="string">'EraseMode'</span>,<span class="string">'background'</span>); <span class="comment">%because 'xor' makes shaft invisible unless Width&gt;1 -- only use in HG2</span>
1100     <span class="keyword">end</span> <span class="comment">%eaj 5/24/16</span>
1101     <span class="keyword">global</span> ARROW_CLICK_H ARROW_CLICK_PROP ARROW_CLICK_AX ARROW_CLICK_USE_Z
1102     ARROW_CLICK_H=H; ARROW_CLICK_PROP=prop; ARROW_CLICK_AX=ax;
1103     ARROW_CLICK_USE_Z=~<a href="#_sub7" class="code" title="subfunction [out,is2D] = arrow_is2DXY(ax)">arrow_is2DXY</a>(ax)|~<a href="#_sub8" class="code" title="subfunction out = arrow_planarkids(ax)">arrow_planarkids</a>(ax);
1104     set(fig,<span class="string">'Pointer'</span>,<span class="string">'crosshair'</span>);
1105     <span class="comment">% set up the WindowButtonMotion so we can see the arrow while moving around</span>
1106     set(fig,<span class="string">'WindowButtonUpFcn'</span>,<span class="string">'set(gcf,''WindowButtonUpFcn'','''')'</span>, <span class="keyword">...</span>
1107             <span class="string">'WindowButtonMotionFcn'</span>,<span class="string">''</span>);
1108     <span class="keyword">if</span> ~lockStart,
1109         set(H,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
1110         set(fig,<span class="string">'WindowButtonMotionFcn'</span>,[mfilename <span class="string">'(''callback'',''motion'');'</span>]);
1111     <span class="keyword">end</span>;
1112     <span class="comment">% wait for the button to be pressed</span>
1113     [wasKeyPress,wasInterrupted,errstr] = <a href="#_sub6" class="code" title="subfunction [wasKeyPress,wasInterrupted,errstr] = arrow_wfbdown(fig)">arrow_wfbdown</a>(fig);
1114     <span class="comment">% if we wanted to click-drag, set the Start point</span>
1115     <span class="keyword">if</span> lockStart &amp; ~wasInterrupted,
1116         pt = <a href="#_sub5" class="code" title="subfunction out = arrow_point(ax,use_z)">arrow_point</a>(ARROW_CLICK_AX,ARROW_CLICK_USE_Z);
1117         feval(mfilename,H,<span class="string">'Start'</span>,pt,<span class="string">'Stop'</span>,pt);
1118         set(H,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
1119         ARROW_CLICK_PROP=<span class="string">'Stop'</span>;
1120         set(fig,<span class="string">'WindowButtonMotionFcn'</span>,[mfilename <span class="string">'(''callback'',''motion'');'</span>]);
1121         <span class="comment">% wait for the mouse button to be released</span>
1122         <span class="keyword">try</span>
1123             waitfor(fig,<span class="string">'WindowButtonUpFcn'</span>,<span class="string">''</span>);
1124         <span class="keyword">catch</span>
1125             errstr = lasterr;
1126             wasInterrupted = 1;
1127         <span class="keyword">end</span>;
1128     <span class="keyword">end</span>;
1129     <span class="keyword">if</span> ~wasInterrupted, feval(mfilename,<span class="string">'callback'</span>,<span class="string">'motion'</span>); <span class="keyword">end</span>;
1130     <span class="comment">% restore some things</span>
1131     set(gcf,oldFigProps,oldFigValue);
1132     set(H,oldArrowProps,oldArrowValue);
1133 
1134 <a name="_sub4" href="#_subfunctions" class="code">function arrow_callback(varargin)</a>
1135 <span class="comment">% handle redrawing callbacks</span>
1136     <span class="keyword">if</span> nargin==0, <span class="keyword">return</span>; <span class="keyword">end</span>;
1137     str = varargin{1};
1138     <span class="keyword">if</span> ~isstr(str), error([upper(mfilename) <span class="string">' got an invalid Callback command.'</span>]); <span class="keyword">end</span>;
1139     s = lower(str);
1140     <span class="keyword">if</span> strcmp(s,<span class="string">'motion'</span>),
1141         <span class="comment">% motion callback</span>
1142         <span class="keyword">global</span> ARROW_CLICK_H ARROW_CLICK_PROP ARROW_CLICK_AX ARROW_CLICK_USE_Z
1143         feval(mfilename,ARROW_CLICK_H,ARROW_CLICK_PROP,<a href="#_sub5" class="code" title="subfunction out = arrow_point(ax,use_z)">arrow_point</a>(ARROW_CLICK_AX,ARROW_CLICK_USE_Z));
1144         drawnow;
1145     <span class="keyword">else</span>,
1146         error([upper(mfilename) <span class="string">' does not recognize '''</span> str(:).' <span class="string">''' as a valid Callback option.'</span>]);
1147     <span class="keyword">end</span>;
1148 
1149 <a name="_sub5" href="#_subfunctions" class="code">function out = arrow_point(ax,use_z)</a>
1150 <span class="comment">% return the point on the given axes</span>
1151     <span class="keyword">if</span> nargin==0, ax=gca; <span class="keyword">end</span>;
1152     <span class="keyword">if</span> nargin&lt;2, use_z=~<a href="#_sub7" class="code" title="subfunction [out,is2D] = arrow_is2DXY(ax)">arrow_is2DXY</a>(ax)|~<a href="#_sub8" class="code" title="subfunction out = arrow_planarkids(ax)">arrow_planarkids</a>(ax); <span class="keyword">end</span>;
1153     out = get(ax,<span class="string">'CurrentPoint'</span>);
1154     out = out(1,:);
1155     <span class="keyword">if</span> ~use_z, out=out(1:2); <span class="keyword">end</span>;
1156 
1157 <a name="_sub6" href="#_subfunctions" class="code">function [wasKeyPress,wasInterrupted,errstr] = arrow_wfbdown(fig)</a>
1158 <span class="comment">% wait for button down ignoring object ButtonDownFcn's</span>
1159     <span class="keyword">if</span> nargin==0, fig=gcf; <span class="keyword">end</span>;
1160     errstr = <span class="string">''</span>;
1161     <span class="comment">% save ButtonDownFcn values</span>
1162     objs = findobj(fig);
1163     buttonDownFcns = get(objs,<span class="string">'ButtonDownFcn'</span>);
1164     mask=~strcmp(buttonDownFcns,<span class="string">''</span>); objs=objs(mask); buttonDownFcns=buttonDownFcns(mask);
1165     set(objs,<span class="string">'ButtonDownFcn'</span>,<span class="string">''</span>);
1166     <span class="comment">% save other figure values</span>
1167     figProps = {<span class="string">'KeyPressFcn'</span>,<span class="string">'WindowButtonDownFcn'</span>};
1168     figValue = get(fig,figProps);
1169     <span class="comment">% do the real work</span>
1170     set(fig,<span class="string">'KeyPressFcn'</span>,<span class="string">'set(gcf,''KeyPressFcn'','''',''WindowButtonDownFcn'','''');'</span>, <span class="keyword">...</span>
1171             <span class="string">'WindowButtonDownFcn'</span>,<span class="string">'set(gcf,''WindowButtonDownFcn'','''')'</span>);
1172     lasterr(<span class="string">''</span>);
1173     <span class="keyword">try</span>
1174         waitfor(fig,<span class="string">'WindowButtonDownFcn'</span>,<span class="string">''</span>);
1175         wasInterrupted = 0;
1176     <span class="keyword">catch</span>
1177         wasInterrupted = 1;
1178     <span class="keyword">end</span>
1179     wasKeyPress = ~wasInterrupted &amp; strcmp(get(fig,<span class="string">'KeyPressFcn'</span>),<span class="string">''</span>);
1180     <span class="keyword">if</span> wasInterrupted, errstr=lasterr; <span class="keyword">end</span>;
1181     <span class="comment">% restore ButtonDownFcn and other figure values</span>
1182     set(objs,<span class="string">'ButtonDownFcn'</span>,buttonDownFcns);
1183     set(fig,figProps,figValue);
1184 
1185 
1186 
1187 <a name="_sub7" href="#_subfunctions" class="code">function [out,is2D] = arrow_is2DXY(ax)</a>
1188 <span class="comment">% check if axes are 2-D X-Y plots</span>
1189     <span class="comment">% may not work for modified camera angles, etc.</span>
1190     out = false(size(ax)); <span class="comment">% 2-D X-Y plots</span>
1191     is2D = out;                     <span class="comment">% any 2-D plots</span>
1192     views = get(ax(:),{<span class="string">'View'</span>});
1193     views = cat(1,views{:});
1194     out(:) = abs(views(:,2))==90;
1195     is2D(:) = out(:) | all(rem(views',90)==0)';
1196 
1197 <a name="_sub8" href="#_subfunctions" class="code">function out = arrow_planarkids(ax)</a>
1198 <span class="comment">% check if axes descendents all have empty ZData (lines,patches,surfaces)</span>
1199     out = true(size(ax));
1200     allkids = get(ax(:),{<span class="string">'Children'</span>});
1201     <span class="keyword">for</span> k=1:length(allkids),
1202         kids = get([findobj(allkids{k},<span class="string">'flat'</span>,<span class="string">'Type'</span>,<span class="string">'line'</span>)
1203                     findobj(allkids{k},<span class="string">'flat'</span>,<span class="string">'Type'</span>,<span class="string">'patch'</span>)
1204                     findobj(allkids{k},<span class="string">'flat'</span>,<span class="string">'Type'</span>,<span class="string">'surface'</span>)],{<span class="string">'ZData'</span>});
1205         <span class="keyword">for</span> j=1:length(kids),
1206             <span class="keyword">if</span> ~isempty(kids{j}), out(k)=logical(0); <span class="keyword">break</span>; <span class="keyword">end</span>;
1207         <span class="keyword">end</span>;
1208     <span class="keyword">end</span>;
1209 
1210 
1211 
1212 <a name="_sub9" href="#_subfunctions" class="code">function arrow_fixlimits(ax,lims)</a>
1213 <span class="comment">% reset the axis limits as necessary</span>
1214     <span class="keyword">if</span> isempty(ax) || isempty(lims), disp([upper(mfilename) <span class="string">' does not remember any axis limits to reset.'</span>]); <span class="keyword">end</span>;
1215     <span class="keyword">for</span> k=1:numel(ax),
1216         <span class="keyword">if</span> any(get(ax(k),<span class="string">'XLim'</span>)~=lims(1:2,k)'), set(ax(k),<span class="string">'XLim'</span>,lims(1:2,k)'); <span class="keyword">end</span>;
1217         <span class="keyword">if</span> any(get(ax(k),<span class="string">'YLim'</span>)~=lims(3:4,k)'), set(ax(k),<span class="string">'YLim'</span>,lims(3:4,k)'); <span class="keyword">end</span>;
1218         <span class="keyword">if</span> any(get(ax(k),<span class="string">'ZLim'</span>)~=lims(5:6,k)'), set(ax(k),<span class="string">'ZLim'</span>,lims(5:6,k)'); <span class="keyword">end</span>;
1219     <span class="keyword">end</span>;
1220 
1221 
1222 
1223 <a name="_sub10" href="#_subfunctions" class="code">function out = arrow_WarpToFill(notstretched,manualcamera,curax)</a>
1224 <span class="comment">% check if we are in &quot;WarpToFill&quot; mode.</span>
1225     out = strcmp(get(curax,<span class="string">'WarpToFill'</span>),<span class="string">'on'</span>);
1226     <span class="comment">% 'WarpToFill' is undocumented, so may need to replace this by</span>
1227     <span class="comment">% out = ~( any(notstretched) &amp; any(manualcamera) );</span>
1228 
1229 
1230 
1231 <a name="_sub11" href="#_subfunctions" class="code">function out = arrow_warnlimits(ax,narrows)</a>
1232 <span class="comment">% create a warning message if we've changed the axis limits</span>
1233     msg = <span class="string">''</span>;
1234     <span class="keyword">switch</span> (numel(ax))
1235         <span class="keyword">case</span> 1, msg=<span class="string">''</span>;
1236         <span class="keyword">case</span> 2, msg=<span class="string">'on two axes '</span>;
1237         <span class="keyword">otherwise</span>, msg=<span class="string">'on several axes '</span>;
1238     <span class="keyword">end</span>;
1239     msg = [upper(mfilename) <span class="string">' changed the axis limits '</span> msg <span class="keyword">...</span>
1240            <span class="string">'when adding the arrow'</span>];
1241     <span class="keyword">if</span> (narrows&gt;1), msg=[msg <span class="string">'s'</span>]; <span class="keyword">end</span>;
1242     out = [msg <span class="string">'.'</span> sprintf(<span class="string">'\n'</span>) <span class="string">'         Call '</span> upper(mfilename) <span class="keyword">...</span>
1243            <span class="string">' FIXLIMITS to reset them now.'</span>];
1244 
1245 
1246 
1247 <a name="_sub12" href="#_subfunctions" class="code">function arrow_copyprops(fm,to)</a>
1248 <span class="comment">% copy line properties to patches</span>
1249     props  = {<span class="string">'EraseMode'</span>,<span class="string">'LineStyle'</span>,<span class="string">'LineWidth'</span>,<span class="string">'Marker'</span>,<span class="string">'MarkerSize'</span>,<span class="keyword">...</span>
1250               <span class="string">'MarkerEdgeColor'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'ButtonDownFcn'</span>,      <span class="keyword">...</span>
1251               <span class="string">'Clipping'</span>,<span class="string">'DeleteFcn'</span>,<span class="string">'BusyAction'</span>,<span class="string">'HandleVisibility'</span>,   <span class="keyword">...</span>
1252               <span class="string">'Selected'</span>,<span class="string">'SelectionHighlight'</span>,<span class="string">'Visible'</span>};
1253     <span class="keyword">if</span> ~isnumeric(findobj(<span class="string">'Type'</span>,<span class="string">'root'</span>)), props(strcmp(props,<span class="string">'EraseMode'</span>))=[]; <span class="keyword">end</span>; <span class="comment">%eaj 5/24/16</span>
1254     lineprops  = {<span class="string">'Color'</span>,    props{:}};
1255     patchprops = {<span class="string">'EdgeColor'</span>,props{:}};
1256     patch2props = {<span class="string">'FaceColor'</span>,patchprops{:}};
1257     fmpatch = strcmp(get(fm,<span class="string">'Type'</span>),<span class="string">'patch'</span>);
1258     topatch = strcmp(get(to,<span class="string">'Type'</span>),<span class="string">'patch'</span>);
1259     set(to( fmpatch&amp; topatch),patch2props,get(fm( fmpatch&amp; topatch),patch2props)); <span class="comment">%p-&gt;p</span>
1260     set(to(~fmpatch&amp;~topatch),lineprops,  get(fm(~fmpatch&amp;~topatch),lineprops  )); <span class="comment">%l-&gt;l</span>
1261     set(to( fmpatch&amp;~topatch),lineprops,  get(fm( fmpatch&amp;~topatch),patchprops )); <span class="comment">%p-&gt;l</span>
1262     set(to(~fmpatch&amp; topatch),patchprops, get(fm(~fmpatch&amp; topatch),lineprops)  ,<span class="string">'FaceColor'</span>,<span class="string">'none'</span>); <span class="comment">%l-&gt;p</span>
1263 
1264 
1265 
1266 <a name="_sub13" href="#_subfunctions" class="code">function arrow_props</a>
1267 <span class="comment">% display further help info about ARROW properties</span>
1268     c = sprintf(<span class="string">'\n'</span>);
1269     disp([c <span class="keyword">...</span>
1270     <span class="string">'ARROW Properties:  Default values are given in [square brackets], and other'</span> c <span class="keyword">...</span>
1271     <span class="string">'                   acceptable equivalent property names are in (parenthesis).'</span> c c <span class="keyword">...</span>
1272     <span class="string">'  Start           The starting points. For N arrows,            B'</span> c <span class="keyword">...</span>
1273     <span class="string">'                  this should be a Nx2 or Nx3 matrix.          /|\           ^'</span> c <span class="keyword">...</span>
1274     <span class="string">'  Stop            The end points. For N arrows, this          /|||\          |'</span> c <span class="keyword">...</span>
1275     <span class="string">'                  should be a Nx2 or Nx3 matrix.             //|||\\        L|'</span> c <span class="keyword">...</span>
1276     <span class="string">'  Length          Length of the arrowhead (in pixels on     ///|||\\\       e|'</span> c <span class="keyword">...</span>
1277     <span class="string">'                  screen, points on a page). [16] (Len)    ////|||\\\\      n|'</span> c <span class="keyword">...</span>
1278     <span class="string">'  BaseAngle       Angle (degrees) of the base angle       /////|D|\\\\\     g|'</span> c <span class="keyword">...</span>
1279     <span class="string">'                  ADE.  For a simple stick arrow, use    ////  |||  \\\\    t|'</span> c <span class="keyword">...</span>
1280     <span class="string">'                  BaseAngle=TipAngle. [90] (Base)       ///    |||    \\\   h|'</span> c <span class="keyword">...</span>
1281     <span class="string">'  TipAngle        Angle (degrees) of tip angle ABC.    //&lt;-----&gt;||      \\   |'</span> c <span class="keyword">...</span>
1282     <span class="string">'                  [16] (Tip)                          /   base |||        \  V'</span> c <span class="keyword">...</span>
1283     <span class="string">'  Width           Width of the base in pixels.  Not  E   angle ||&lt;--------&gt;C'</span> c <span class="keyword">...</span>
1284     <span class="string">'                  the ''LineWidth'' prop. [0] (Wid)            |||tipangle'</span> c <span class="keyword">...</span>
1285     <span class="string">'  Page            If provided, non-empty, and not NaN,         |||'</span> c <span class="keyword">...</span>
1286     <span class="string">'                  this causes ARROW to use hardcopy            |||'</span> c <span class="keyword">...</span>
1287     <span class="string">'                  rather than onscreen proportions.             A'</span> c <span class="keyword">...</span>
1288     <span class="string">'                  This is important if screen aspect        --&gt;   &lt;-- width'</span> c <span class="keyword">...</span>
1289     <span class="string">'                  ratio and hardcopy aspect ratio are    ----CrossDir----&gt;'</span> c <span class="keyword">...</span>
1290     <span class="string">'                  vastly different. []'</span> c<span class="keyword">...</span>
1291     <span class="string">'  CrossDir        A vector giving the direction towards which the fletches'</span> c <span class="keyword">...</span>
1292     <span class="string">'                  on the arrow should go.  [computed such that it is perpen-'</span> c <span class="keyword">...</span>
1293     <span class="string">'                  dicular to both the arrow direction and the view direction'</span> c <span class="keyword">...</span>
1294     <span class="string">'                  (i.e., as if it was pasted on a normal 2-D graph)]  (Note'</span> c <span class="keyword">...</span>
1295     <span class="string">'                  that CrossDir is a vector.  Also note that if an axis is'</span> c <span class="keyword">...</span>
1296     <span class="string">'                  plotted on a log scale, then the corresponding component'</span> c <span class="keyword">...</span>
1297     <span class="string">'                  of CrossDir must also be set appropriately, i.e., to 1 for'</span> c <span class="keyword">...</span>
1298     <span class="string">'                  no change in that direction, &gt;1 for a positive change, &gt;0'</span> c <span class="keyword">...</span>
1299     <span class="string">'                  and &lt;1 for negative change.)'</span> c <span class="keyword">...</span>
1300     <span class="string">'  NormalDir       A vector normal to the fletch direction (CrossDir is then'</span> c <span class="keyword">...</span>
1301     <span class="string">'                  computed by the vector cross product [Line]x[NormalDir]). []'</span> c <span class="keyword">...</span>
1302     <span class="string">'                  (Note that NormalDir is a vector.  Unlike CrossDir,'</span> c <span class="keyword">...</span>
1303     <span class="string">'                  NormalDir is used as is regardless of log-scaled axes.)'</span> c <span class="keyword">...</span>
1304     <span class="string">'  Ends            Set which end has an arrowhead.  Valid values are ''none'','</span> c <span class="keyword">...</span>
1305     <span class="string">'                  ''stop'', ''start'', and ''both''. [''stop''] (End)'</span> c<span class="keyword">...</span>
1306     <span class="string">'  ShortenLength   Shorten length of arrowhead(s) if line is too short'</span> c <span class="keyword">...</span>
1307     <span class="string">'  ObjectHandles   Vector of handles to previously-created arrows to be'</span> c <span class="keyword">...</span>
1308     <span class="string">'                  updated or line objects to be converted to arrows.'</span> c <span class="keyword">...</span>
1309     <span class="string">'                  [] (Object,Handle)'</span> c <span class="keyword">...</span>
1310     <span class="string">'  Type            ''patch'' creates the arrow with a PATCH object (the default)'</span> c <span class="keyword">...</span>
1311     <span class="string">'                  and ''line'' creates it with a LINE object [''patch''].'</span> c <span class="keyword">...</span>
1312     <span class="string">'  Color           For patch arrows (the default), set both ''FaceColor'' and'</span> c <span class="keyword">...</span>
1313     <span class="string">'                  ''EdgeColor'' to the given value.  For line arrows, set'</span> c <span class="keyword">...</span>
1314     <span class="string">'                  the ''Color'' property to the given value.'</span> c <span class="keyword">...</span>
1315     ]);
1316 
1317 
1318 
1319 <a name="_sub14" href="#_subfunctions" class="code">function out = arrow_demo</a>
1320      <span class="comment">% demo</span>
1321     <span class="comment">% create the data</span>
1322     [x,y,z] = peaks;
1323     [ddd,out.iii]=max(z(:));
1324     out.axlim = [min(x(:)) max(x(:)) min(y(:)) max(y(:)) min(z(:)) max(z(:))];
1325     
1326     <span class="comment">% modify it by inserting some NaN's</span>
1327     [m,n] = size(z);
1328     m = floor(m/2);
1329     n = floor(n/2);
1330     z(1:m,1:n) = NaN*ones(m,n);
1331     
1332     <span class="comment">% graph it</span>
1333     clf(<span class="string">'reset'</span>);
1334     out.hs=surf(x,y,z);
1335     out.x=x; out.y=y; out.z=z;
1336     xlabel(<span class="string">'x'</span>); ylabel(<span class="string">'y'</span>);
1337             
1338 <a name="_sub15" href="#_subfunctions" class="code">function h = arrow_demo3(in)</a>
1339     <span class="comment">% set the view</span>
1340     axlim = in.axlim;
1341     axis(axlim);
1342     zlabel(<span class="string">'z'</span>);
1343     <span class="comment">%set(in.hs,'FaceColor','interp');</span>
1344     view(3); <span class="comment">% view(viewmtx(-37.5,30,20));</span>
1345     title([<span class="string">'Demo of the capabilities of the ARROW function in 3-D'</span>]);
1346     
1347     <span class="comment">% Normal blue arrow</span>
1348     h1 = feval(mfilename,[axlim(1) axlim(4) 4],[-.8 1.2 4], <span class="keyword">...</span>
1349                <span class="string">'EdgeColor'</span>,<span class="string">'b'</span>,<span class="string">'FaceColor'</span>,<span class="string">'b'</span>);
1350     
1351     <span class="comment">% Normal white arrow, clipped by the surface</span>
1352     h2 = feval(mfilename,axlim([1 4 6]),[0 2 4]);
1353     t=text(-2.4,2.7,7.7,<span class="string">'arrow clipped by surf'</span>);
1354     
1355     <span class="comment">% Baseangle&lt;90</span>
1356     h3 = feval(mfilename,[3 .125 3.5],[1.375 0.125 3.5],30,50);
1357     t2=text(3.1,.125,3.5,<span class="string">'local maximum'</span>);
1358     
1359     <span class="comment">% Baseangle&lt;90, fill and edge colors different</span>
1360     h4 = feval(mfilename,axlim(1:2:5)*.5,[0 0 0],36,60,25, <span class="keyword">...</span>
1361                <span class="string">'EdgeColor'</span>,<span class="string">'b'</span>,<span class="string">'FaceColor'</span>,<span class="string">'c'</span>);
1362     t3=text(axlim(1)*.5,axlim(3)*.5,axlim(5)*.5-.75,<span class="string">'origin'</span>);
1363     set(t3,<span class="string">'HorizontalAlignment'</span>,<span class="string">'center'</span>);
1364     
1365     <span class="comment">% Baseangle&gt;90, black fill</span>
1366     h5 = feval(mfilename,[-2.9 2.9 3],[-1.3 .4 3.2],30,120,[],6, <span class="keyword">...</span>
1367                <span class="string">'EdgeColor'</span>,<span class="string">'r'</span>,<span class="string">'FaceColor'</span>,<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,2);
1368     
1369     <span class="comment">% Baseangle&gt;90, no fill</span>
1370     h6 = feval(mfilename,[-2.9 2.9 1.3],[-1.3 .4 1.5],30,120,[],6, <span class="keyword">...</span>
1371                <span class="string">'EdgeColor'</span>,<span class="string">'r'</span>,<span class="string">'FaceColor'</span>,<span class="string">'none'</span>,<span class="string">'LineWidth'</span>,2);
1372     
1373     <span class="comment">% Stick arrow</span>
1374     h7 = feval(mfilename,[-1.6 -1.65 -6.5],[0 -1.65 -6.5],[],16,16);
1375     t4=text(-1.5,-1.65,-7.25,<span class="string">'global mininum'</span>);
1376     set(t4,<span class="string">'HorizontalAlignment'</span>,<span class="string">'center'</span>);
1377     
1378     <span class="comment">% Normal, black fill</span>
1379     h8 = feval(mfilename,[-1.4 0 -7.2],[-1.4 0 -3],<span class="string">'FaceColor'</span>,<span class="string">'k'</span>);
1380     t5=text(-1.5,0,-7.75,<span class="string">'local minimum'</span>);
1381     set(t5,<span class="string">'HorizontalAlignment'</span>,<span class="string">'center'</span>);
1382     
1383     <span class="comment">% Gray fill, crossdir specified, 'LineStyle' --</span>
1384     h9 = feval(mfilename,[-3 2.2 -6],[-3 2.2 -.05],36,[],27,6,[],[0 -1 0], <span class="keyword">...</span>
1385                <span class="string">'EdgeColor'</span>,<span class="string">'k'</span>,<span class="string">'FaceColor'</span>,.75*[1 1 1],<span class="string">'LineStyle'</span>,<span class="string">'--'</span>);
1386     
1387     <span class="comment">% a series of normal arrows, linearly spaced, crossdir specified</span>
1388     h10y=(0:4)'/3;
1389     h10 = feval(mfilename,[-3*ones(size(h10y)) h10y -6.5*ones(size(h10y))], <span class="keyword">...</span>
1390                 [-3*ones(size(h10y)) h10y -.05*ones(size(h10y))], <span class="keyword">...</span>
1391                 12,[],[],[],[],[0 -1 0]);
1392     
1393     <span class="comment">% a series of normal arrows, linearly spaced</span>
1394     h11x=(1:.33:2.8)';
1395     h11 = feval(mfilename,[h11x -3*ones(size(h11x)) 6.5*ones(size(h11x))], <span class="keyword">...</span>
1396                 [h11x -3*ones(size(h11x)) -.05*ones(size(h11x))]);
1397     
1398     <span class="comment">% series of magenta arrows, radially oriented, crossdir specified</span>
1399     h12x=2; h12y=-3; h12z=axlim(5)/2; h12xr=1; h12zr=h12z; ir=.15;or=.81;
1400     h12t=(0:11)'/6*pi;
1401     h12 = feval(mfilename,                                           <span class="keyword">...</span>
1402                 [h12x+h12xr*cos(h12t)*ir h12y*ones(size(h12t))       <span class="keyword">...</span>
1403                  h12z+h12zr*sin(h12t)*ir],[h12x+h12xr*cos(h12t)*or   <span class="keyword">...</span>
1404                  h12y*ones(size(h12t)) h12z+h12zr*sin(h12t)*or],     <span class="keyword">...</span>
1405                 10,[],[],[],[],                                      <span class="keyword">...</span>
1406                 [-h12xr*sin(h12t) zeros(size(h12t)) h12zr*cos(h12t)],<span class="keyword">...</span>
1407                 <span class="string">'FaceColor'</span>,<span class="string">'none'</span>,<span class="string">'EdgeColor'</span>,<span class="string">'m'</span>);
1408     
1409     <span class="comment">% series of normal arrows, tangentially oriented, crossdir specified</span>
1410     or13=.91; h13t=(0:.5:12)'/6*pi;
1411     locs = [h12x+h12xr*cos(h13t)*or13 h12y*ones(size(h13t)) h12z+h12zr*sin(h13t)*or13];
1412     h13 = feval(mfilename,locs(1:end-1,:),locs(2:<span class="keyword">end</span>,:),6);
1413     
1414     <span class="comment">% arrow with no line ==&gt; oriented downwards</span>
1415     h14 = feval(mfilename,[3 3 .100001],[3 3 .1],30);
1416     t6=text(3,3,3.6,<span class="string">'no line'</span>); set(t6,<span class="string">'HorizontalAlignment'</span>,<span class="string">'center'</span>);
1417     
1418     <span class="comment">% arrow with arrowheads at both ends</span>
1419     h15 = feval(mfilename,[-.5 -3 -3],[1 -3 -3],<span class="string">'Ends'</span>,<span class="string">'both'</span>,<span class="string">'FaceColor'</span>,<span class="string">'g'</span>, <span class="keyword">...</span>
1420                 <span class="string">'Length'</span>,20,<span class="string">'Width'</span>,3,<span class="string">'CrossDir'</span>,[0 0 1],<span class="string">'TipAngle'</span>,25);
1421     
1422     h=[h1;h2;h3;h4;h5;h6;h7;h8;h9;h10;h11;h12;h13;h14;h15];
1423 
1424 <a name="_sub16" href="#_subfunctions" class="code">function h = arrow_demo2(in)</a>
1425     axlim = in.axlim;
1426     dolog = 1;
1427     <span class="keyword">if</span> (dolog), set(in.hs,<span class="string">'YData'</span>,10.^get(in.hs,<span class="string">'YData'</span>)); <span class="keyword">end</span>;
1428     shading(<span class="string">'interp'</span>);
1429     view(2);
1430     title([<span class="string">'Demo of the capabilities of the ARROW function in 2-D'</span>]);
1431     hold on; [C,H]=contour(in.x,in.y,in.z,20,<span class="string">'-'</span>); hold off;
1432     <span class="keyword">for</span> k=H',
1433         set(k,<span class="string">'ZData'</span>,(axlim(6)+1)*ones(size(get(k,<span class="string">'XData'</span>))),<span class="string">'Color'</span>,<span class="string">'k'</span>);
1434         <span class="keyword">if</span> (dolog), set(k,<span class="string">'YData'</span>,10.^get(k,<span class="string">'YData'</span>)); <span class="keyword">end</span>;
1435     <span class="keyword">end</span>;
1436     <span class="keyword">if</span> (dolog), axis([axlim(1:2) 10.^axlim(3:4)]); set(gca,<span class="string">'YScale'</span>,<span class="string">'log'</span>);
1437     <span class="keyword">else</span>,       axis(axlim(1:4)); <span class="keyword">end</span>;
1438     
1439     <span class="comment">% Normal blue arrow</span>
1440     start = [axlim(1) axlim(4) axlim(6)+2];
1441     stop  = [in.x(in.iii) in.y(in.iii) axlim(6)+2];
1442     <span class="keyword">if</span> (dolog), start(:,2)=10.^start(:,2); stop(:,2)=10.^stop(:,2); <span class="keyword">end</span>;
1443     h1 = feval(mfilename,start,stop,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>,<span class="string">'FaceColor'</span>,<span class="string">'b'</span>);
1444     
1445     <span class="comment">% three arrows with varying fill, width, and baseangle</span>
1446     start = [-3   -3   10; -3   -1.5 10; -1.5 -3   10];
1447     stop  = [-.03 -.03 10; -.03 -1.5 10; -1.5 -.03 10];
1448     <span class="keyword">if</span> (dolog), start(:,2)=10.^start(:,2); stop(:,2)=10.^stop(:,2); <span class="keyword">end</span>;
1449     h2 = feval(mfilename,start,stop,24,[90;60;120],[],[0;0;4],<span class="string">'Ends'</span>,str2mat(<span class="string">'both'</span>,<span class="string">'stop'</span>,<span class="string">'stop'</span>));
1450     set(h2(2),<span class="string">'EdgeColor'</span>,[0 .35 0],<span class="string">'FaceColor'</span>,[0 .85 .85]);
1451     set(h2(3),<span class="string">'EdgeColor'</span>,<span class="string">'r'</span>,<span class="string">'FaceColor'</span>,[1 .5 1]);
1452     h=[h1;h2];
1453 
1454 <a name="_sub17" href="#_subfunctions" class="code">function out = trueornan(x)</a>
1455 <span class="keyword">if</span> isempty(x),
1456     out=x;
1457 <span class="keyword">else</span>,
1458     out = isnan(x);
1459     out(~out) = x(~out);
1460 <span class="keyword">end</span>;</pre></div>
<hr><address>Generated on Thu 26-Aug-2021 19:28:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>